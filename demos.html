<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⟡</text></svg>">
    <title>偏振光交互学习 - PolarCraft</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: #121218;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            color: #e0e0e0;
        }

        /* Navigation Header */
        .nav-header {
            background: rgba(20, 20, 30, 0.95);
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }

        .nav-header .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: inherit;
        }

        .nav-header .logo-icon {
            font-size: 28px;
            color: #64c8ff;
        }

        .nav-header .logo-text {
            font-size: 20px;
            font-weight: bold;
            color: #64c8ff;
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-links a {
            color: #889;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .nav-links a:hover {
            color: #fff;
            background: rgba(100, 200, 255, 0.1);
        }

        .nav-links a.active {
            color: #64c8ff;
            background: rgba(100, 200, 255, 0.15);
        }

        /* Main Container */
        .main-container {
            display: flex;
            padding-top: 70px;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: rgba(20, 20, 30, 0.8);
            border-right: 1px solid rgba(100, 200, 255, 0.1);
            height: calc(100vh - 70px);
            position: fixed;
            left: 0;
            top: 70px;
            overflow-y: auto;
            padding: 20px 0;
        }

        .sidebar-section {
            padding: 0 15px;
            margin-bottom: 25px;
        }

        .sidebar-section h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #556;
            margin-bottom: 10px;
            padding-left: 10px;
        }

        .demo-list {
            list-style: none;
        }

        .demo-list li {
            margin-bottom: 2px;
        }

        .demo-list a {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            color: #aab;
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.2s;
            font-size: 14px;
        }

        .demo-list a:hover {
            background: rgba(100, 200, 255, 0.1);
            color: #fff;
        }

        .demo-list a.active {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
        }

        .demo-list .demo-num {
            width: 22px;
            height: 22px;
            background: rgba(100, 200, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #64c8ff;
        }

        /* Content Area */
        .content {
            flex: 1;
            margin-left: 280px;
            padding: 30px;
            min-height: calc(100vh - 70px);
        }

        /* Demo Section */
        .demo-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .demo-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .demo-header {
            margin-bottom: 30px;
        }

        .demo-header h1 {
            font-size: 32px;
            color: #fff;
            margin-bottom: 10px;
        }

        .demo-header .subtitle {
            font-size: 16px;
            color: #64c8ff;
            margin-bottom: 15px;
        }

        .demo-header p {
            color: #889;
            line-height: 1.7;
            max-width: 800px;
        }

        /* Demo Container */
        .demo-container {
            background: #1e1e28;
            border-radius: 16px;
            border: 1px solid rgba(100, 200, 255, 0.15);
            overflow: hidden;
            margin-bottom: 30px;
        }

        .demo-canvas-area {
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
        }

        .demo-canvas-area canvas {
            background: #000;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 100%;
        }

        .demo-controls {
            padding: 25px 30px;
            background: rgba(30, 30, 40, 0.5);
            border-top: 1px solid rgba(100, 200, 255, 0.1);
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            min-width: 140px;
            font-size: 14px;
            color: #aab;
        }

        .control-row input[type="range"] {
            flex: 1;
            max-width: 400px;
            cursor: pointer;
        }

        .control-row .value {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            color: #64c8ff;
            font-size: 14px;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-btn {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #aab;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: rgba(100, 200, 255, 0.2);
            color: #fff;
            border-color: rgba(100, 200, 255, 0.5);
        }

        /* Info Panel */
        .info-panel {
            background: rgba(30, 40, 60, 0.5);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid rgba(100, 200, 255, 0.1);
        }

        .info-panel h3 {
            color: #64c8ff;
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-panel p {
            color: #aab;
            line-height: 1.7;
            margin-bottom: 12px;
        }

        .info-panel p:last-child {
            margin-bottom: 0;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.3em;
            text-align: center;
            color: #ffcc00;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        /* Status Display */
        .status-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px 20px;
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
        }

        .status-item {
            text-align: center;
        }

        .status-item .label {
            font-size: 12px;
            color: #667;
            margin-bottom: 5px;
        }

        .status-item .value {
            font-size: 20px;
            font-weight: bold;
            color: #ffcc00;
            font-family: monospace;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar {
                display: none;
            }
            .content {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <header class="nav-header">
        <a href="index.html" class="logo">
            <span class="logo-icon">⟡</span>
            <span class="logo-text">PolarCraft</span>
        </a>
        <nav class="nav-links">
            <a href="index.html">首页</a>
            <a href="demos.html" class="active">交互学习</a>
            <a href="game.html">游戏探索</a>
        </nav>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <div class="sidebar-section">
                <h3>第一单元：偏振态调制与测量</h3>
                <ul class="demo-list">
                    <li><a href="#demo3" class="active" data-demo="demo3">
                        <span class="demo-num">1.1</span>
                        偏振态与相位
                    </a></li>
                    <li><a href="#demo1" data-demo="demo1">
                        <span class="demo-num">1.2</span>
                        马吕斯定律
                    </a></li>
                    <li><a href="#demo4" data-demo="demo4">
                        <span class="demo-num">1.3</span>
                        双折射晶体
                    </a></li>
                    <li><a href="#demo5" data-demo="demo5">
                        <span class="demo-num">1.4</span>
                        波片效应
                    </a></li>
                </ul>
            </div>
            <div class="sidebar-section">
                <h3>第二单元：界面反射偏振</h3>
                <ul class="demo-list">
                    <li><a href="#demo6" data-demo="demo6">
                        <span class="demo-num">2.1</span>
                        布儒斯特角
                    </a></li>
                </ul>
            </div>
            <div class="sidebar-section">
                <h3>第三单元：透明介质偏振</h3>
                <ul class="demo-list">
                    <li><a href="#demo7" data-demo="demo7">
                        <span class="demo-num">3.1</span>
                        色偏振与干涉
                    </a></li>
                    <li><a href="#demo8" data-demo="demo8">
                        <span class="demo-num">3.2</span>
                        旋光性
                    </a></li>
                    <li><a href="#demo9" data-demo="demo9">
                        <span class="demo-num">3.3</span>
                        光弹性效应
                    </a></li>
                </ul>
            </div>
            <div class="sidebar-section">
                <h3>第四单元：浑浊介质散射</h3>
                <ul class="demo-list">
                    <li><a href="#demo10" data-demo="demo10">
                        <span class="demo-num">4.1</span>
                        瑞利与米氏散射
                    </a></li>
                </ul>
            </div>
            <div class="sidebar-section">
                <h3>第五单元：全偏振技术</h3>
                <ul class="demo-list">
                    <li><a href="#demo11" data-demo="demo11">
                        <span class="demo-num">5.1</span>
                        Stokes矢量与Mueller矩阵
                    </a></li>
                </ul>
            </div>
            <div class="sidebar-section">
                <h3>游戏探索</h3>
                <ul class="demo-list">
                    <li><a href="#demo2" data-demo="demo2">
                        <span class="demo-num">⚡</span>
                        PolarCraft 游戏原型
                    </a></li>
                </ul>
            </div>
        </aside>

        <main class="content">
            <!-- Demo 1: Malus's Law -->
            <section id="demo1" class="demo-section">
                <div class="demo-header">
                    <h1>马吕斯定律</h1>
                    <p class="subtitle">Malus's Law - 偏振光通过检偏器的强度变化</p>
                    <p>当线偏振光通过检偏器（分析器）时，透射光强度与偏振方向和检偏器透光轴夹角的余弦平方成正比。这是偏振光学中最基础也是最重要的定律之一。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas1" width="550" height="300"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="control-row">
                            <label>检偏器角度 (θ):</label>
                            <input type="range" id="angle1" min="0" max="360" value="0">
                            <span class="value" id="angle1Val">0°</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <div class="formula">I = I<sub>0</sub> cos²(θ)</div>
                    <p><strong>马吕斯定律</strong>（1809年）描述了偏振光通过偏振片时的强度变化规律。其中 I₀ 是入射光强，θ 是入射光偏振方向与偏振片透光轴的夹角。</p>
                    <p>当 θ = 0° 时，光强最大（I = I₀）；当 θ = 90° 时，光强为零（消光状态）。这个定律是所有偏振光学实验和应用的基础。</p>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">透射光强</div>
                            <div class="value" id="intensity1">100%</div>
                        </div>
                        <div class="status-item">
                            <div class="label">cos²(θ)</div>
                            <div class="value" id="cos2val1">1.00</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 2: Game Prototype -->
            <section id="demo2" class="demo-section">
                <div class="demo-header">
                    <h1>PolarCraft 游戏原型</h1>
                    <p class="subtitle">Interactive Game Demo - 偏振光解谜游戏机制</p>
                    <p>这是 PolarCraft 游戏的核心机制演示。通过旋转偏振片来控制光的透过率，让足够的光能量到达传感器以开启机关。这展示了如何将物理原理转化为游戏玩法。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area" style="padding: 20px;">
                        <div id="game-proto" style="position: relative; width: 300px; height: 420px; background: #222; border: 2px solid #444; display: flex; flex-direction: column; align-items: center;">
                            <div style="position: absolute; top: 10px; left: 10px; font-size: 12px; color: #888;">光强: <span id="intensity2">100</span>%</div>
                            <div style="width: 20px; height: 20px; background: white; border-radius: 50%; margin-top: 20px; box-shadow: 0 0 20px white; z-index: 10;"></div>
                            <div id="beam2-1" style="position: absolute; top: 40px; width: 6px; height: 60px; background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0)); z-index: 1;"></div>
                            <div id="filter2-1" style="width: 100px; height: 100px; border: 4px solid #00d2ff; background: rgba(0, 210, 255, 0.1); position: absolute; top: 80px; display: flex; justify-content: center; align-items: center;">
                                <div style="width: 80%; height: 80%; background: repeating-linear-gradient(90deg, transparent, transparent 9px, rgba(0, 210, 255, 0.5) 10px);"></div>
                                <span style="position:absolute; color:#00d2ff; font-size:10px; background:#222;">固定: 0°</span>
                            </div>
                            <div id="beam2-2" style="position: absolute; top: 180px; width: 6px; height: 60px; background: linear-gradient(to bottom, rgba(0,210,255,0.8), rgba(0,210,255,0)); z-index: 1;"></div>
                            <div id="filter2-2" style="width: 100px; height: 100px; border: 4px solid #ffcc00; background: rgba(255, 204, 0, 0.1); position: absolute; top: 220px; display: flex; justify-content: center; align-items: center; transition: transform 0.1s;">
                                <div style="width: 80%; height: 80%; background: repeating-linear-gradient(90deg, transparent, transparent 9px, rgba(255, 204, 0, 0.5) 10px);"></div>
                            </div>
                            <div id="beam2-3" style="position: absolute; top: 320px; width: 6px; height: 60px; background: linear-gradient(to bottom, rgba(255,204,0,0.8), rgba(255,204,0,0)); z-index: 1;"></div>
                            <div id="sensor2" style="position: absolute; bottom: 20px; width: 50px; height: 50px; background: #333; border: 2px solid #555; display: flex; justify-content: center; align-items: center; font-size: 28px; border-radius: 8px;">🔒</div>
                        </div>
                    </div>
                    <div class="demo-controls">
                        <div class="control-row">
                            <label>旋转下方偏振片:</label>
                            <input type="range" id="angle2" min="0" max="180" value="90">
                            <span class="value" id="angle2Val">90°</span>
                        </div>
                        <p id="status2" style="color: #ff5555; margin-top: 10px; text-align: center;">光路被阻断！</p>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>游戏机制</h3>
                    <p><strong>目标：</strong>调整可旋转的偏振片角度，使足够的光能量（>80%）到达底部的传感器来开启机关。</p>
                    <p><strong>规则：</strong>第一个偏振片固定为 0°（垂直偏振），第二个偏振片可以旋转。当两个偏振片的透光轴夹角接近 90° 时，几乎没有光能通过（消光）。</p>
                    <p>这个简单的机制可以扩展为更复杂的谜题，包括多个偏振片、分束器、波片等光学元件的组合。</p>
                </div>
            </section>

            <!-- Demo 3: Polarization States -->
            <section id="demo3" class="demo-section active">
                <div class="demo-header">
                    <h1>偏振态与相位差</h1>
                    <p class="subtitle">Polarization States - 线偏振、圆偏振与椭圆偏振</p>
                    <p>光的偏振状态由两个正交电场分量的振幅比和相位差共同决定。通过调节这两个参数，可以产生线偏振、圆偏振或椭圆偏振光。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area" style="flex-direction: row; gap: 30px; flex-wrap: wrap;">
                        <div style="text-align: center;">
                            <h4 style="color: #889; margin-bottom: 10px;">3D 空间传播视图</h4>
                            <canvas id="canvas3-3d" width="500" height="280"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <h4 style="color: #889; margin-bottom: 10px;">偏振态投影</h4>
                            <canvas id="canvas3-2d" width="280" height="280"></canvas>
                        </div>
                    </div>
                    <div class="demo-controls">
                        <div class="preset-buttons" style="margin-bottom: 20px;">
                            <button class="preset-btn" onclick="setDemo3Preset(0, 1, 0)">线偏振 (水平)</button>
                            <button class="preset-btn" onclick="setDemo3Preset(0, 1, 1)">线偏振 (45°)</button>
                            <button class="preset-btn" onclick="setDemo3Preset(90, 1, 1)">圆偏振</button>
                            <button class="preset-btn" onclick="setDemo3Preset(45, 1, 1)">椭圆偏振</button>
                        </div>
                        <div class="control-row">
                            <label>相位差 (δ):</label>
                            <input type="range" id="phase3" min="0" max="360" value="0">
                            <span class="value" id="phase3Val">0°</span>
                        </div>
                        <div class="control-row">
                            <label>Ex 振幅:</label>
                            <input type="range" id="ampX3" min="0" max="100" value="100">
                            <span class="value" id="ampX3Val">1.0</span>
                        </div>
                        <div class="control-row">
                            <label>Ey 振幅:</label>
                            <input type="range" id="ampY3" min="0" max="100" value="100">
                            <span class="value" id="ampY3Val">1.0</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <p>光波的电场可以分解为两个互相垂直的分量 Ex 和 Ey。偏振态取决于：</p>
                    <p><strong>1. 线偏振：</strong>当相位差 δ = 0° 或 180° 时，合成电场矢量在一条直线上振动。</p>
                    <p><strong>2. 圆偏振：</strong>当 δ = 90° 且 Ex = Ey 时，电场矢量端点描绘出一个圆。</p>
                    <p><strong>3. 椭圆偏振：</strong>一般情况下，电场矢量端点描绘出一个椭圆。</p>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:#ff4444;"></div>Ex (水平分量)</div>
                        <div class="legend-item"><div class="legend-color" style="background:#44ff44;"></div>Ey (垂直分量)</div>
                        <div class="legend-item"><div class="legend-color" style="background:#ffff00;"></div>E (合成矢量)</div>
                    </div>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">当前偏振态</div>
                            <div class="value" id="state3" style="font-size: 16px;">线偏振</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 4: Birefringence -->
            <section id="demo4" class="demo-section">
                <div class="demo-header">
                    <h1>双折射晶体</h1>
                    <p class="subtitle">Birefringence - 方解石等晶体的双折射现象</p>
                    <p>某些各向异性晶体（如方解石）具有双折射特性：一束光进入晶体后会分裂成两束偏振方向互相垂直的光——寻常光（o光）和非寻常光（e光）。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas4" width="600" height="350"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="control-row">
                            <label>入射光偏振角度:</label>
                            <input type="range" id="inAngle4" min="0" max="90" value="45">
                            <span class="value" id="inAngle4Val">45°</span>
                        </div>
                        <div class="control-row">
                            <label>晶体光轴方向:</label>
                            <input type="range" id="axisAngle4" min="0" max="90" value="0">
                            <span class="value" id="axisAngle4Val">0°</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <p><strong>双折射</strong>是各向异性晶体的光学特性。进入晶体的光被分解为：</p>
                    <p><strong>o光（寻常光）：</strong>偏振方向垂直于光轴所在平面，遵循普通折射定律，折射率为 n<sub>o</sub>。</p>
                    <p><strong>e光（非寻常光）：</strong>偏振方向在光轴所在平面内，折射率 n<sub>e</sub> 随传播方向变化。</p>
                    <div class="formula">分光比例：I<sub>o</sub> = I<sub>0</sub>sin²(θ), I<sub>e</sub> = I<sub>0</sub>cos²(θ)</div>
                    <p>当入射光偏振角为 45° 时，两束光强度相等。当偏振角为 0° 或 90° 时，只有一束光出射。</p>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:#00ff88;"></div>o光 (寻常光)</div>
                        <div class="legend-item"><div class="legend-color" style="background:#ff8800;"></div>e光 (非寻常光)</div>
                    </div>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">o光强度</div>
                            <div class="value" id="oIntensity4">50%</div>
                        </div>
                        <div class="status-item">
                            <div class="label">e光强度</div>
                            <div class="value" id="eIntensity4">50%</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 5: Wave Plates -->
            <section id="demo5" class="demo-section">
                <div class="demo-header">
                    <h1>波片效应</h1>
                    <p class="subtitle">Wave Plates - λ/4 和 λ/2 波片的作用</p>
                    <p>波片是一种光学元件，利用双折射效应在快轴和慢轴方向上产生特定的相位延迟，从而改变光的偏振状态。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area" style="flex-direction: row; gap: 40px; flex-wrap: wrap;">
                        <div style="text-align: center;">
                            <h4 style="color: #889; margin-bottom: 10px;">入射偏振态</h4>
                            <canvas id="canvas5-in" width="200" height="200"></canvas>
                        </div>
                        <div style="text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="font-size: 40px; color: #64c8ff;">→</div>
                            <div id="waveplate5" style="width: 80px; height: 120px; border: 3px solid #64c8ff; border-radius: 8px; background: rgba(100, 200, 255, 0.1); display: flex; align-items: center; justify-content: center; font-size: 14px; color: #64c8ff;">λ/4</div>
                            <div style="font-size: 40px; color: #64c8ff;">→</div>
                        </div>
                        <div style="text-align: center;">
                            <h4 style="color: #889; margin-bottom: 10px;">出射偏振态</h4>
                            <canvas id="canvas5-out" width="200" height="200"></canvas>
                        </div>
                    </div>
                    <div class="demo-controls">
                        <div class="preset-buttons" style="margin-bottom: 20px;">
                            <button class="preset-btn" onclick="setDemo5Preset('quarter')">λ/4 波片</button>
                            <button class="preset-btn" onclick="setDemo5Preset('half')">λ/2 波片</button>
                            <button class="preset-btn" onclick="setDemo5Preset('full')">λ 波片</button>
                        </div>
                        <div class="control-row">
                            <label>波片相位延迟:</label>
                            <input type="range" id="retard5" min="0" max="360" value="90">
                            <span class="value" id="retard5Val">90° (λ/4)</span>
                        </div>
                        <div class="control-row">
                            <label>入射偏振角:</label>
                            <input type="range" id="inPol5" min="0" max="90" value="45">
                            <span class="value" id="inPol5Val">45°</span>
                        </div>
                        <div class="control-row">
                            <label>波片快轴角度:</label>
                            <input type="range" id="fastAxis5" min="0" max="90" value="0">
                            <span class="value" id="fastAxis5Val">0°</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <p>波片利用双折射材料制成，快轴方向的光比慢轴方向的光传播更快，产生相位差：</p>
                    <div class="formula">δ = (2π/λ) × (n<sub>e</sub> - n<sub>o</sub>) × d</div>
                    <p><strong>λ/4 波片（δ = 90°）：</strong>将 45° 线偏振光转换为圆偏振光，或将圆偏振光转换为线偏振光。</p>
                    <p><strong>λ/2 波片（δ = 180°）：</strong>将线偏振光的偏振方向旋转 2θ（θ 为偏振方向与快轴的夹角）。</p>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">入射态</div>
                            <div class="value" id="inState5" style="font-size: 14px;">线偏振</div>
                        </div>
                        <div class="status-item">
                            <div class="label">出射态</div>
                            <div class="value" id="outState5" style="font-size: 14px;">圆偏振</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 6: Brewster's Angle -->
            <section id="demo6" class="demo-section">
                <div class="demo-header">
                    <h1>布儒斯特角</h1>
                    <p class="subtitle">Brewster's Angle - 反射光的完全偏振化</p>
                    <p>当光以特定角度（布儒斯特角）入射到两种介质的界面时，反射光将完全偏振化，偏振方向垂直于入射面。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas6" width="600" height="400"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="control-row">
                            <label>入射角:</label>
                            <input type="range" id="incAngle6" min="0" max="89" value="56">
                            <span class="value" id="incAngle6Val">56°</span>
                        </div>
                        <div class="control-row">
                            <label>介质折射率 (n₂):</label>
                            <input type="range" id="n2_6" min="100" max="200" value="150">
                            <span class="value" id="n2Val6">1.50</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <div class="formula">tan(θ<sub>B</sub>) = n₂ / n₁</div>
                    <p><strong>布儒斯特定律：</strong>当入射角等于布儒斯特角 θ<sub>B</sub> 时，反射光和折射光互相垂直，此时 p 偏振分量（平行于入射面）的反射率为零，反射光完全由 s 偏振分量（垂直于入射面）组成。</p>
                    <p>对于空气-玻璃界面（n = 1.5），布儒斯特角约为 56.3°。这一原理被广泛应用于偏振器设计、减少反射损耗等领域。</p>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background:#ff6666;"></div>p 偏振 (平行入射面)</div>
                        <div class="legend-item"><div class="legend-color" style="background:#6666ff;"></div>s 偏振 (垂直入射面)</div>
                    </div>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">布儒斯特角</div>
                            <div class="value" id="brewster6">56.3°</div>
                        </div>
                        <div class="status-item">
                            <div class="label">p反射率</div>
                            <div class="value" id="rp6">0%</div>
                        </div>
                        <div class="status-item">
                            <div class="label">s反射率</div>
                            <div class="value" id="rs6">14%</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 7: Interference -->
            <section id="demo7" class="demo-section">
                <div class="demo-header">
                    <h1>色偏振与干涉</h1>
                    <p class="subtitle">Chromatic Polarization - 双折射介质的彩色效应</p>
                    <p>当白光通过双折射介质并经过检偏器时，由于不同波长的光经历不同的相位延迟，会产生美丽的干涉色彩。这就是色偏振现象，广泛应用于应力分析、材料检测等领域。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas7" width="600" height="350"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="control-row">
                            <label>光束1偏振角:</label>
                            <input type="range" id="pol7a" min="0" max="180" value="0">
                            <span class="value" id="pol7aVal">0°</span>
                        </div>
                        <div class="control-row">
                            <label>光束2偏振角:</label>
                            <input type="range" id="pol7b" min="0" max="180" value="0">
                            <span class="value" id="pol7bVal">0°</span>
                        </div>
                        <div class="control-row">
                            <label>相位差:</label>
                            <input type="range" id="phase7" min="0" max="360" value="0">
                            <span class="value" id="phase7Val">0°</span>
                        </div>
                        <div class="control-row">
                            <label>振幅比 (A₂/A₁):</label>
                            <input type="range" id="ampRatio7" min="0" max="100" value="100">
                            <span class="value" id="ampRatio7Val">1.0</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <p><strong>干涉条件：</strong>只有偏振方向有平行分量的光才能发生干涉。两束正交偏振的光不会产生干涉条纹。</p>
                    <div class="formula">I = I₁ + I₂ + 2√(I₁I₂) cos(Δφ) cos²(θ₁₂/2)</div>
                    <p>其中 θ₁₂ 是两束光偏振方向的夹角，Δφ 是相位差。</p>
                    <p><strong>相长干涉：</strong>相位差 Δφ = 0°, 360°... 时，光强最大。</p>
                    <p><strong>相消干涉：</strong>相位差 Δφ = 180° 时，若振幅相等则光强为零。</p>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">干涉类型</div>
                            <div class="value" id="intType7" style="font-size: 14px;">相长干涉</div>
                        </div>
                        <div class="status-item">
                            <div class="label">合成光强</div>
                            <div class="value" id="resultI7">200%</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 8: Optical Activity -->
            <section id="demo8" class="demo-section">
                <div class="demo-header">
                    <h1>旋光性</h1>
                    <p class="subtitle">Optical Activity - 手性分子对偏振面的旋转</p>
                    <p>某些物质（如糖溶液、石英晶体）能够旋转通过它的线偏振光的偏振方向。旋转角度与物质的浓度和光程长度成正比。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas8" width="600" height="320"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="preset-buttons" style="margin-bottom: 20px;">
                            <button class="preset-btn" onclick="setDemo8Preset('sugar')">蔗糖溶液</button>
                            <button class="preset-btn" onclick="setDemo8Preset('quartz')">石英晶体</button>
                            <button class="preset-btn" onclick="setDemo8Preset('fructose')">果糖溶液 (左旋)</button>
                        </div>
                        <div class="control-row">
                            <label>溶液浓度 (g/mL):</label>
                            <input type="range" id="conc8" min="0" max="100" value="50">
                            <span class="value" id="conc8Val">0.50</span>
                        </div>
                        <div class="control-row">
                            <label>光程长度 (dm):</label>
                            <input type="range" id="path8" min="1" max="20" value="10">
                            <span class="value" id="path8Val">1.0</span>
                        </div>
                        <div class="control-row">
                            <label>旋光率 [α] (°/dm·g/mL):</label>
                            <input type="range" id="alpha8" min="-100" max="100" value="66">
                            <span class="value" id="alpha8Val">+66.5</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <div class="formula">α = [α] × c × l</div>
                    <p>旋光角 α 等于比旋光度 [α] 乘以浓度 c 和光程长度 l。</p>
                    <p><strong>右旋物质（+）：</strong>从光传播方向看，偏振面顺时针旋转。如蔗糖（[α] = +66.5°）。</p>
                    <p><strong>左旋物质（-）：</strong>从光传播方向看，偏振面逆时针旋转。如果糖（[α] = -92°）。</p>
                    <p>旋光性源于分子的手性结构，是糖度计、偏光显微镜等仪器的工作原理基础。</p>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">旋转角度</div>
                            <div class="value" id="rotation8">+33.3°</div>
                        </div>
                        <div class="status-item">
                            <div class="label">旋转方向</div>
                            <div class="value" id="direction8" style="font-size: 14px;">右旋</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 9: Photoelasticity -->
            <section id="demo9" class="demo-section">
                <div class="demo-header">
                    <h1>光弹性效应</h1>
                    <p class="subtitle">Photoelasticity - 应力双折射可视化</p>
                    <p>透明材料在应力作用下会产生双折射，当置于正交偏振片之间时，应力分布会形成彩色干涉条纹，这是光弹性分析的基础。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas9" width="500" height="400"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="preset-buttons" style="margin-bottom: 20px;">
                            <button class="preset-btn" onclick="setDemo9Preset('point')">点载荷</button>
                            <button class="preset-btn" onclick="setDemo9Preset('tension')">拉伸应力</button>
                            <button class="preset-btn" onclick="setDemo9Preset('bend')">弯曲应力</button>
                            <button class="preset-btn" onclick="setDemo9Preset('hole')">圆孔应力集中</button>
                        </div>
                        <div class="control-row">
                            <label>应力大小:</label>
                            <input type="range" id="stress9" min="0" max="100" value="50">
                            <span class="value" id="stress9Val">50%</span>
                        </div>
                        <div class="control-row">
                            <label>检偏器角度:</label>
                            <input type="range" id="analyzerAngle9" min="0" max="90" value="90">
                            <span class="value" id="analyzerAngle9Val">90°</span>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <p><strong>应力-光学定律：</strong>材料在应力作用下产生的双折射量与应力差成正比：</p>
                    <div class="formula">Δn = C × (σ₁ - σ₂)</div>
                    <p>其中 C 是应力-光学系数，σ₁ 和 σ₂ 是主应力。</p>
                    <p><strong>等色线（Isochromatic）：</strong>相同颜色的线连接了主应力差相等的点。</p>
                    <p><strong>等倾线（Isoclinic）：</strong>黑色条纹出现在主应力方向与偏振器轴平行或垂直的位置。</p>
                    <p>光弹性分析被广泛应用于工程结构应力分析、断裂力学研究等领域。</p>
                </div>
            </section>

            <!-- Demo 10: Scattering -->
            <section id="demo10" class="demo-section">
                <div class="demo-header">
                    <h1>瑞利与米氏散射</h1>
                    <p class="subtitle">Rayleigh & Mie Scattering - 颗粒物散射的光谱与偏振特征</p>
                    <p>光被颗粒物散射时，散射强度和偏振特征与颗粒物的粒径、形状和折射率密切相关。瑞利散射解释蓝天，米氏散射解释白云和红霞。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas10" width="700" height="400"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="control-row">
                            <label>颗粒粒径 (nm):</label>
                            <input type="range" id="particleSize10" min="10" max="2000" value="100" step="10">
                            <span class="value" id="particleSize10Val">100nm</span>
                        </div>
                        <div class="control-row">
                            <label>观察角度:</label>
                            <input type="range" id="observeAngle10" min="0" max="180" value="90">
                            <span class="value" id="observeAngle10Val">90°</span>
                        </div>
                        <div class="control-row">
                            <label style="min-width: 140px;">快速预设:</label>
                            <div class="preset-buttons">
                                <button class="preset-btn" onclick="setScatterPreset('sky')">蓝天 (瑞利)</button>
                                <button class="preset-btn" onclick="setScatterPreset('cloud')">白云 (米氏)</button>
                                <button class="preset-btn" onclick="setScatterPreset('sunset')">红霞</button>
                                <button class="preset-btn" onclick="setScatterPreset('milk')">牛奶散射</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <p><strong>瑞利散射（Rayleigh Scattering）：</strong>当颗粒粒径远小于光波长时（d &lt;&lt; λ），散射强度与波长的四次方成反比：</p>
                    <div class="formula">I ∝ 1/λ⁴</div>
                    <p>这解释了为什么天空是蓝色的——短波长（蓝光）比长波长（红光）散射更强。</p>
                    <p><strong>米氏散射（Mie Scattering）：</strong>当颗粒粒径与光波长相当时（d ≈ λ），散射变得复杂，各波长散射接近，因此云呈现白色。</p>
                    <p><strong>散射偏振：</strong>侧向散射光（90°）偏振度最高，前向和后向散射偏振度较低。</p>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">散射类型</div>
                            <div class="value" id="scatterType10">瑞利散射</div>
                        </div>
                        <div class="status-item">
                            <div class="label">偏振度</div>
                            <div class="value" id="polarDegree10">85%</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Demo 11: Mueller Matrix -->
            <section id="demo11" class="demo-section">
                <div class="demo-header">
                    <h1>Stokes矢量与Mueller矩阵</h1>
                    <p class="subtitle">Full Polarimetry - 偏振光学的完备表征</p>
                    <p>Stokes矢量完整描述光的偏振态，Mueller矩阵完整描述光学元件对偏振态的变换。两者结合构成全偏振光学测量的数学基础。</p>
                </div>
                <div class="demo-container">
                    <div class="demo-canvas-area">
                        <canvas id="canvas11" width="700" height="450"></canvas>
                    </div>
                    <div class="demo-controls">
                        <div class="control-row">
                            <label>入射光类型:</label>
                            <div class="preset-buttons">
                                <button class="preset-btn" onclick="setStokesInput('horizontal')">水平偏振</button>
                                <button class="preset-btn" onclick="setStokesInput('vertical')">垂直偏振</button>
                                <button class="preset-btn" onclick="setStokesInput('diagonal')">45°偏振</button>
                                <button class="preset-btn" onclick="setStokesInput('circular_r')">右旋圆偏振</button>
                                <button class="preset-btn" onclick="setStokesInput('circular_l')">左旋圆偏振</button>
                            </div>
                        </div>
                        <div class="control-row">
                            <label>光学元件:</label>
                            <div class="preset-buttons">
                                <button class="preset-btn" onclick="setMuellerElement('polarizer_h')">水平偏振片</button>
                                <button class="preset-btn" onclick="setMuellerElement('polarizer_45')">45°偏振片</button>
                                <button class="preset-btn" onclick="setMuellerElement('qwp')">四分之一波片</button>
                                <button class="preset-btn" onclick="setMuellerElement('hwp')">二分之一波片</button>
                                <button class="preset-btn" onclick="setMuellerElement('depolarizer')">退偏器</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="info-panel">
                    <h3>物理原理</h3>
                    <p><strong>Stokes矢量：</strong>用四个可测量的参数完整描述光的偏振态：</p>
                    <div class="formula">S = [S₀, S₁, S₂, S₃]ᵀ</div>
                    <ul style="margin: 15px 0; padding-left: 20px; color: #aab;">
                        <li>S₀: 总光强</li>
                        <li>S₁: 水平偏振 - 垂直偏振</li>
                        <li>S₂: +45°偏振 - -45°偏振</li>
                        <li>S₃: 右旋圆偏振 - 左旋圆偏振</li>
                    </ul>
                    <p><strong>Mueller矩阵：</strong>4×4矩阵，完整描述光学元件对偏振态的变换：</p>
                    <div class="formula">S' = M · S</div>
                    <p>Mueller矩阵是样本偏振光学特征的完备表征，包含极其丰富的光学性质和微观结构几何特征信息，在海洋探测、生物医学、材料检测、自动驾驶等领域有广泛应用。</p>
                    <div class="status-display">
                        <div class="status-item">
                            <div class="label">入射Stokes</div>
                            <div class="value" id="stokesIn11">[1,1,0,0]</div>
                        </div>
                        <div class="status-item">
                            <div class="label">出射Stokes</div>
                            <div class="value" id="stokesOut11">[0.5,0.5,0,0]</div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Navigation
        document.querySelectorAll('.demo-list a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const demoId = link.dataset.demo;

                // Update active states
                document.querySelectorAll('.demo-list a').forEach(l => l.classList.remove('active'));
                link.classList.add('active');

                document.querySelectorAll('.demo-section').forEach(s => s.classList.remove('active'));
                document.getElementById(demoId).classList.add('active');
            });
        });

        // Utility functions
        function toRad(deg) { return deg * Math.PI / 180; }
        function toDeg(rad) { return rad * 180 / Math.PI; }

        // ============ DEMO 1: Malus's Law ============
        const canvas1 = document.getElementById('canvas1');
        const ctx1 = canvas1.getContext('2d');
        const angle1Slider = document.getElementById('angle1');
        let angle1 = 0;
        let time1 = 0;

        function updateDemo1() {
            angle1 = parseInt(angle1Slider.value);
            document.getElementById('angle1Val').textContent = angle1 + '°';

            const rad = toRad(angle1);
            const intensity = Math.pow(Math.cos(rad), 2);
            document.getElementById('intensity1').textContent = Math.round(intensity * 100) + '%';
            document.getElementById('cos2val1').textContent = intensity.toFixed(2);
        }

        function drawDemo1() {
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            const width = canvas1.width;
            const height = canvas1.height;
            const centerY = height / 2;

            const rad = toRad(angle1);
            const amplitudeFactor = Math.abs(Math.cos(rad));

            // Axis
            ctx1.strokeStyle = '#333';
            ctx1.lineWidth = 1;
            ctx1.beginPath();
            ctx1.moveTo(0, centerY);
            ctx1.lineTo(width, centerY);
            ctx1.stroke();

            // Polarizer 1 (fixed)
            const p1X = width * 0.2;
            ctx1.save();
            ctx1.translate(p1X, centerY);
            ctx1.strokeStyle = '#00ccff';
            ctx1.lineWidth = 4;
            ctx1.beginPath();
            ctx1.arc(0, 0, 40, 0, Math.PI * 2);
            ctx1.stroke();
            ctx1.lineWidth = 2;
            ctx1.beginPath();
            ctx1.moveTo(0, -35);
            ctx1.lineTo(0, 35);
            ctx1.stroke();
            ctx1.fillStyle = '#00ccff';
            ctx1.font = '14px Arial';
            ctx1.textAlign = 'center';
            ctx1.fillText('起偏器 (固定)', 0, -55);
            ctx1.restore();

            // Polarizer 2 (rotating)
            const p2X = width * 0.8;
            ctx1.save();
            ctx1.translate(p2X, centerY);
            ctx1.rotate(rad);
            ctx1.strokeStyle = '#ffcc00';
            ctx1.lineWidth = 4;
            ctx1.beginPath();
            ctx1.arc(0, 0, 40, 0, Math.PI * 2);
            ctx1.stroke();
            ctx1.lineWidth = 2;
            ctx1.beginPath();
            ctx1.moveTo(0, -35);
            ctx1.lineTo(0, 35);
            ctx1.stroke();
            ctx1.restore();

            ctx1.fillStyle = '#ffcc00';
            ctx1.font = '14px Arial';
            ctx1.textAlign = 'center';
            ctx1.fillText('检偏器', p2X, centerY - 55);

            // Waves
            // Before P1
            ctx1.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx1.lineWidth = 1;
            ctx1.beginPath();
            for (let x = 0; x < p1X - 40; x++) {
                const y = centerY + Math.sin((x - time1) * 0.1) * 20 + Math.cos((x + time1) * 0.15) * 15;
                if (x === 0) ctx1.moveTo(x, y);
                else ctx1.lineTo(x, y);
            }
            ctx1.stroke();

            // Between P1 and P2
            ctx1.strokeStyle = '#00ccff';
            ctx1.lineWidth = 2;
            ctx1.beginPath();
            for (let x = p1X + 40; x < p2X - 40; x++) {
                const y = centerY + Math.sin((x - time1) * 0.1) * 30;
                if (x === p1X + 40) ctx1.moveTo(x, y);
                else ctx1.lineTo(x, y);
            }
            ctx1.stroke();

            // After P2
            ctx1.strokeStyle = `rgba(255, 204, 0, ${0.2 + amplitudeFactor * 0.8})`;
            ctx1.lineWidth = 2;
            ctx1.beginPath();
            for (let x = p2X + 40; x < width; x++) {
                const y = centerY + Math.sin((x - time1) * 0.1) * 30 * amplitudeFactor;
                if (x === p2X + 40) ctx1.moveTo(x, y);
                else ctx1.lineTo(x, y);
            }
            ctx1.stroke();

            time1 += 2;
            requestAnimationFrame(drawDemo1);
        }

        angle1Slider.addEventListener('input', updateDemo1);
        updateDemo1();
        drawDemo1();

        // ============ DEMO 2: Game Prototype ============
        const angle2Slider = document.getElementById('angle2');
        const filter2 = document.getElementById('filter2-2');
        const beam3 = document.getElementById('beam2-3');
        const sensor2 = document.getElementById('sensor2');

        function updateDemo2() {
            const theta = parseInt(angle2Slider.value);
            document.getElementById('angle2Val').textContent = theta + '°';

            filter2.style.transform = `rotate(${theta}deg)`;

            const rad = toRad(theta);
            const intensity = Math.pow(Math.cos(rad), 2);
            const percent = Math.round(intensity * 100);

            document.getElementById('intensity2').textContent = percent;
            beam3.style.opacity = intensity;

            if (percent > 80) {
                sensor2.classList.add('active');
                sensor2.textContent = '🔓';
                sensor2.style.background = '#0f0';
                sensor2.style.boxShadow = '0 0 30px #0f0';
                document.getElementById('status2').textContent = '能量充足！门已开启';
                document.getElementById('status2').style.color = '#0f0';
            } else {
                sensor2.classList.remove('active');
                sensor2.textContent = '🔒';
                sensor2.style.background = '#333';
                sensor2.style.boxShadow = 'none';
                if (percent < 10) {
                    document.getElementById('status2').textContent = '光路被阻断 (消光状态)';
                    document.getElementById('status2').style.color = '#555';
                } else {
                    document.getElementById('status2').textContent = '能量不足...';
                    document.getElementById('status2').style.color = '#ff5555';
                }
            }
        }

        angle2Slider.addEventListener('input', updateDemo2);
        updateDemo2();

        // ============ DEMO 3: Polarization States ============
        const canvas3_3d = document.getElementById('canvas3-3d');
        const ctx3_3d = canvas3_3d.getContext('2d');
        const canvas3_2d = document.getElementById('canvas3-2d');
        const ctx3_2d = canvas3_2d.getContext('2d');

        let phase3 = 0, ampX3 = 1, ampY3 = 1, time3 = 0;

        function setDemo3Preset(p, ax, ay) {
            document.getElementById('phase3').value = p;
            document.getElementById('ampX3').value = ax * 100;
            document.getElementById('ampY3').value = ay * 100;
            updateDemo3Values();
        }

        function updateDemo3Values() {
            phase3 = parseInt(document.getElementById('phase3').value);
            ampX3 = parseInt(document.getElementById('ampX3').value) / 100;
            ampY3 = parseInt(document.getElementById('ampY3').value) / 100;

            document.getElementById('phase3Val').textContent = phase3 + '°';
            document.getElementById('ampX3Val').textContent = ampX3.toFixed(1);
            document.getElementById('ampY3Val').textContent = ampY3.toFixed(1);

            let state = '椭圆偏振';
            if (Math.abs(ampX3 - ampY3) < 0.1 && (Math.abs(phase3 - 90) < 5 || Math.abs(phase3 - 270) < 5)) {
                state = '圆偏振';
            } else if (phase3 < 5 || Math.abs(phase3 - 180) < 5 || phase3 > 355) {
                state = '线偏振';
            } else if (ampX3 < 0.05 || ampY3 < 0.05) {
                state = '线偏振';
            }
            document.getElementById('state3').textContent = state;
        }

        function drawDemo3() {
            // 3D View
            ctx3_3d.clearRect(0, 0, canvas3_3d.width, canvas3_3d.height);
            const w = canvas3_3d.width, h = canvas3_3d.height;
            const axisY = h / 2;

            ctx3_3d.strokeStyle = '#333';
            ctx3_3d.beginPath();
            ctx3_3d.moveTo(0, axisY);
            ctx3_3d.lineTo(w, axisY);
            ctx3_3d.stroke();

            const k = 0.05, speed = 0.1, scale = 35;
            const slantX = 0.5, slantY = -0.3;
            const phaseRad = toRad(phase3);

            // Ex component
            ctx3_3d.strokeStyle = 'rgba(255, 68, 68, 0.5)';
            ctx3_3d.lineWidth = 2;
            ctx3_3d.beginPath();
            for (let i = 0; i < w; i += 2) {
                const val = ampX3 * Math.cos(k * i - time3 * speed);
                const sx = i + val * scale * slantX;
                const sy = axisY + val * scale * slantY;
                if (i === 0) ctx3_3d.moveTo(sx, sy);
                else ctx3_3d.lineTo(sx, sy);
            }
            ctx3_3d.stroke();

            // Ey component
            ctx3_3d.strokeStyle = 'rgba(68, 255, 68, 0.5)';
            ctx3_3d.beginPath();
            for (let i = 0; i < w; i += 2) {
                const val = ampY3 * Math.cos(k * i - time3 * speed + phaseRad);
                const sy = axisY - val * scale;
                if (i === 0) ctx3_3d.moveTo(i, sy);
                else ctx3_3d.lineTo(i, sy);
            }
            ctx3_3d.stroke();

            // Resultant
            ctx3_3d.strokeStyle = '#ffff00';
            ctx3_3d.lineWidth = 3;
            ctx3_3d.beginPath();
            for (let i = 0; i < w; i++) {
                const valX = ampX3 * Math.cos(k * i - time3 * speed);
                const valY = ampY3 * Math.cos(k * i - time3 * speed + phaseRad);
                const sx = i + valX * scale * slantX;
                const sy = axisY + (valX * scale * slantY) - (valY * scale);
                if (i === 0) ctx3_3d.moveTo(sx, sy);
                else ctx3_3d.lineTo(sx, sy);
            }
            ctx3_3d.stroke();

            // 2D Cross Section
            ctx3_2d.clearRect(0, 0, canvas3_2d.width, canvas3_2d.height);
            const cx = canvas3_2d.width / 2, cy = canvas3_2d.height / 2;
            const radius = 70;

            ctx3_2d.strokeStyle = '#444';
            ctx3_2d.beginPath();
            ctx3_2d.moveTo(cx, 0);
            ctx3_2d.lineTo(cx, canvas3_2d.height);
            ctx3_2d.stroke();
            ctx3_2d.beginPath();
            ctx3_2d.moveTo(0, cy);
            ctx3_2d.lineTo(canvas3_2d.width, cy);
            ctx3_2d.stroke();

            // Trace
            ctx3_2d.strokeStyle = 'rgba(255, 255, 0, 0.4)';
            ctx3_2d.lineWidth = 2;
            ctx3_2d.beginPath();
            for (let a = 0; a <= Math.PI * 2; a += 0.05) {
                const px = ampX3 * Math.cos(a) * radius;
                const py = ampY3 * Math.cos(a + phaseRad) * radius;
                if (a === 0) ctx3_2d.moveTo(cx + px, cy - py);
                else ctx3_2d.lineTo(cx + px, cy - py);
            }
            ctx3_2d.closePath();
            ctx3_2d.stroke();

            // Current vector
            const vecX = ampX3 * Math.cos(-time3 * speed) * radius;
            const vecY = ampY3 * Math.cos(-time3 * speed + phaseRad) * radius;

            ctx3_2d.strokeStyle = '#ffff00';
            ctx3_2d.lineWidth = 3;
            ctx3_2d.beginPath();
            ctx3_2d.moveTo(cx, cy);
            ctx3_2d.lineTo(cx + vecX, cy - vecY);
            ctx3_2d.stroke();

            ctx3_2d.fillStyle = '#ffff00';
            ctx3_2d.beginPath();
            ctx3_2d.arc(cx + vecX, cy - vecY, 5, 0, Math.PI * 2);
            ctx3_2d.fill();

            time3++;
            requestAnimationFrame(drawDemo3);
        }

        document.getElementById('phase3').addEventListener('input', updateDemo3Values);
        document.getElementById('ampX3').addEventListener('input', updateDemo3Values);
        document.getElementById('ampY3').addEventListener('input', updateDemo3Values);
        updateDemo3Values();
        drawDemo3();

        // ============ DEMO 4: Birefringence ============
        const canvas4 = document.getElementById('canvas4');
        const ctx4 = canvas4.getContext('2d');
        let time4 = 0;

        function updateDemo4() {
            const inAngle = parseInt(document.getElementById('inAngle4').value);
            const axisAngle = parseInt(document.getElementById('axisAngle4').value);
            document.getElementById('inAngle4Val').textContent = inAngle + '°';
            document.getElementById('axisAngle4Val').textContent = axisAngle + '°';

            const rad = toRad(inAngle - axisAngle);
            const oInt = Math.pow(Math.sin(rad), 2);
            const eInt = Math.pow(Math.cos(rad), 2);

            document.getElementById('oIntensity4').textContent = Math.round(oInt * 100) + '%';
            document.getElementById('eIntensity4').textContent = Math.round(eInt * 100) + '%';
        }

        function drawDemo4() {
            ctx4.clearRect(0, 0, canvas4.width, canvas4.height);
            const w = canvas4.width, h = canvas4.height;
            const cy = h / 2;

            const inAngle = parseInt(document.getElementById('inAngle4').value);
            const axisAngle = parseInt(document.getElementById('axisAngle4').value);
            const rad = toRad(inAngle - axisAngle);
            const oAmp = Math.abs(Math.sin(rad));
            const eAmp = Math.abs(Math.cos(rad));

            // Crystal
            const crystalX = w * 0.35;
            const crystalW = w * 0.3;
            ctx4.fillStyle = 'rgba(100, 200, 255, 0.15)';
            ctx4.strokeStyle = 'rgba(100, 200, 255, 0.5)';
            ctx4.lineWidth = 2;
            ctx4.beginPath();
            ctx4.moveTo(crystalX, cy - 80);
            ctx4.lineTo(crystalX + crystalW, cy - 80);
            ctx4.lineTo(crystalX + crystalW + 30, cy);
            ctx4.lineTo(crystalX + crystalW, cy + 80);
            ctx4.lineTo(crystalX, cy + 80);
            ctx4.lineTo(crystalX - 30, cy);
            ctx4.closePath();
            ctx4.fill();
            ctx4.stroke();

            ctx4.fillStyle = '#64c8ff';
            ctx4.font = '14px Arial';
            ctx4.textAlign = 'center';
            ctx4.fillText('方解石晶体', crystalX + crystalW/2, cy - 100);

            // Optical axis indicator
            ctx4.save();
            ctx4.translate(crystalX + crystalW/2, cy);
            ctx4.rotate(toRad(axisAngle));
            ctx4.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx4.setLineDash([5, 5]);
            ctx4.beginPath();
            ctx4.moveTo(-60, 0);
            ctx4.lineTo(60, 0);
            ctx4.stroke();
            ctx4.setLineDash([]);
            ctx4.fillStyle = '#888';
            ctx4.font = '12px Arial';
            ctx4.fillText('光轴', 70, 5);
            ctx4.restore();

            // Input beam
            ctx4.strokeStyle = '#ffcc00';
            ctx4.lineWidth = 2;
            ctx4.beginPath();
            for (let x = 20; x < crystalX - 30; x++) {
                const y = cy + Math.sin((x - time4) * 0.15) * 20;
                if (x === 20) ctx4.moveTo(x, y);
                else ctx4.lineTo(x, y);
            }
            ctx4.stroke();

            ctx4.fillStyle = '#ffcc00';
            ctx4.font = '12px Arial';
            ctx4.textAlign = 'left';
            ctx4.fillText(`入射光 (${inAngle}°)`, 20, cy - 40);

            // O-ray (ordinary)
            const oEndX = w - 40;
            const oEndY = cy + 40;
            ctx4.strokeStyle = `rgba(0, 255, 136, ${0.3 + oAmp * 0.7})`;
            ctx4.lineWidth = 2 + oAmp * 2;
            ctx4.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const x = (crystalX + crystalW + 30) + (oEndX - crystalX - crystalW - 30) * t;
                const y = cy + (oEndY - cy) * t + Math.sin((x - time4) * 0.15) * 15 * oAmp;
                if (t === 0) ctx4.moveTo(x, y);
                else ctx4.lineTo(x, y);
            }
            ctx4.stroke();

            ctx4.fillStyle = '#00ff88';
            ctx4.fillText(`o光 (${Math.round(oAmp*100)}%)`, oEndX - 80, oEndY + 30);

            // E-ray (extraordinary)
            const eEndY = cy - 40;
            ctx4.strokeStyle = `rgba(255, 136, 0, ${0.3 + eAmp * 0.7})`;
            ctx4.lineWidth = 2 + eAmp * 2;
            ctx4.beginPath();
            for (let t = 0; t <= 1; t += 0.02) {
                const x = (crystalX + crystalW + 30) + (oEndX - crystalX - crystalW - 30) * t;
                const y = cy + (eEndY - cy) * t + Math.sin((x - time4) * 0.15) * 15 * eAmp;
                if (t === 0) ctx4.moveTo(x, y);
                else ctx4.lineTo(x, y);
            }
            ctx4.stroke();

            ctx4.fillStyle = '#ff8800';
            ctx4.fillText(`e光 (${Math.round(eAmp*100)}%)`, oEndX - 80, eEndY - 20);

            time4 += 2;
            requestAnimationFrame(drawDemo4);
        }

        document.getElementById('inAngle4').addEventListener('input', updateDemo4);
        document.getElementById('axisAngle4').addEventListener('input', updateDemo4);
        updateDemo4();
        drawDemo4();

        // ============ DEMO 5: Wave Plates ============
        const canvas5In = document.getElementById('canvas5-in');
        const ctx5In = canvas5In.getContext('2d');
        const canvas5Out = document.getElementById('canvas5-out');
        const ctx5Out = canvas5Out.getContext('2d');
        let time5 = 0;

        function setDemo5Preset(type) {
            if (type === 'quarter') document.getElementById('retard5').value = 90;
            else if (type === 'half') document.getElementById('retard5').value = 180;
            else if (type === 'full') document.getElementById('retard5').value = 360;
            updateDemo5();
        }

        function updateDemo5() {
            const retard = parseInt(document.getElementById('retard5').value);
            const inPol = parseInt(document.getElementById('inPol5').value);
            const fastAxis = parseInt(document.getElementById('fastAxis5').value);

            let retardLabel = retard + '°';
            if (Math.abs(retard - 90) < 5) retardLabel = '90° (λ/4)';
            else if (Math.abs(retard - 180) < 5) retardLabel = '180° (λ/2)';
            else if (Math.abs(retard - 360) < 5 || retard < 5) retardLabel = '360° (λ)';

            document.getElementById('retard5Val').textContent = retardLabel;
            document.getElementById('inPol5Val').textContent = inPol + '°';
            document.getElementById('fastAxis5Val').textContent = fastAxis + '°';
            document.getElementById('waveplate5').textContent =
                Math.abs(retard - 90) < 5 ? 'λ/4' :
                Math.abs(retard - 180) < 5 ? 'λ/2' :
                Math.abs(retard - 360) < 5 ? 'λ' : `${retard}°`;

            document.getElementById('inState5').textContent = '线偏振 ' + inPol + '°';

            const theta = toRad(inPol - fastAxis);
            const delta = toRad(retard);

            if (Math.abs(retard - 90) < 5 && Math.abs(Math.abs(theta) - Math.PI/4) < 0.1) {
                document.getElementById('outState5').textContent = '圆偏振';
            } else if (Math.abs(retard - 180) < 5) {
                const newAngle = 2 * fastAxis - inPol;
                document.getElementById('outState5').textContent = '线偏振 ' + ((newAngle + 180) % 180) + '°';
            } else if (retard < 5 || Math.abs(retard - 360) < 5) {
                document.getElementById('outState5').textContent = '线偏振 ' + inPol + '° (不变)';
            } else {
                document.getElementById('outState5').textContent = '椭圆偏振';
            }
        }

        function drawDemo5() {
            const retard = parseInt(document.getElementById('retard5').value);
            const inPol = parseInt(document.getElementById('inPol5').value);
            const fastAxis = parseInt(document.getElementById('fastAxis5').value);

            // Input (always linear)
            ctx5In.clearRect(0, 0, 200, 200);
            const cx = 100, cy = 100, r = 60;

            ctx5In.strokeStyle = '#444';
            ctx5In.beginPath();
            ctx5In.moveTo(cx, 0); ctx5In.lineTo(cx, 200);
            ctx5In.moveTo(0, cy); ctx5In.lineTo(200, cy);
            ctx5In.stroke();

            const inRad = toRad(inPol);
            ctx5In.strokeStyle = '#ffff00';
            ctx5In.lineWidth = 3;
            ctx5In.beginPath();
            ctx5In.moveTo(cx - Math.cos(inRad) * r, cy - Math.sin(inRad) * r);
            ctx5In.lineTo(cx + Math.cos(inRad) * r, cy + Math.sin(inRad) * r);
            ctx5In.stroke();

            // Output
            ctx5Out.clearRect(0, 0, 200, 200);
            ctx5Out.strokeStyle = '#444';
            ctx5Out.beginPath();
            ctx5Out.moveTo(cx, 0); ctx5Out.lineTo(cx, 200);
            ctx5Out.moveTo(0, cy); ctx5Out.lineTo(200, cy);
            ctx5Out.stroke();

            const theta = inPol - fastAxis;
            const thetaRad = toRad(theta);
            const delta = toRad(retard);

            // Calculate output amplitudes
            const aFast = Math.cos(thetaRad);
            const aSlow = Math.sin(thetaRad);

            ctx5Out.strokeStyle = 'rgba(255, 255, 0, 0.4)';
            ctx5Out.lineWidth = 2;
            ctx5Out.beginPath();

            for (let t = 0; t <= Math.PI * 2; t += 0.05) {
                const eFast = aFast * Math.cos(t);
                const eSlow = aSlow * Math.cos(t + delta);

                const ex = eFast * Math.cos(toRad(fastAxis)) - eSlow * Math.sin(toRad(fastAxis));
                const ey = eFast * Math.sin(toRad(fastAxis)) + eSlow * Math.cos(toRad(fastAxis));

                if (t === 0) ctx5Out.moveTo(cx + ex * r, cy - ey * r);
                else ctx5Out.lineTo(cx + ex * r, cy - ey * r);
            }
            ctx5Out.closePath();
            ctx5Out.stroke();

            // Animated vector
            const tNow = time5 * 0.1;
            const eFastNow = aFast * Math.cos(tNow);
            const eSlowNow = aSlow * Math.cos(tNow + delta);
            const exNow = eFastNow * Math.cos(toRad(fastAxis)) - eSlowNow * Math.sin(toRad(fastAxis));
            const eyNow = eFastNow * Math.sin(toRad(fastAxis)) + eSlowNow * Math.cos(toRad(fastAxis));

            ctx5Out.strokeStyle = '#ffff00';
            ctx5Out.lineWidth = 3;
            ctx5Out.beginPath();
            ctx5Out.moveTo(cx, cy);
            ctx5Out.lineTo(cx + exNow * r, cy - eyNow * r);
            ctx5Out.stroke();

            ctx5Out.fillStyle = '#ffff00';
            ctx5Out.beginPath();
            ctx5Out.arc(cx + exNow * r, cy - eyNow * r, 5, 0, Math.PI * 2);
            ctx5Out.fill();

            time5++;
            requestAnimationFrame(drawDemo5);
        }

        document.getElementById('retard5').addEventListener('input', updateDemo5);
        document.getElementById('inPol5').addEventListener('input', updateDemo5);
        document.getElementById('fastAxis5').addEventListener('input', updateDemo5);
        updateDemo5();
        drawDemo5();

        // ============ DEMO 6: Brewster's Angle ============
        const canvas6 = document.getElementById('canvas6');
        const ctx6 = canvas6.getContext('2d');

        function updateDemo6() {
            const incAngle = parseInt(document.getElementById('incAngle6').value);
            const n2 = parseInt(document.getElementById('n2_6').value) / 100;

            document.getElementById('incAngle6Val').textContent = incAngle + '°';
            document.getElementById('n2Val6').textContent = n2.toFixed(2);

            const brewsterAngle = toDeg(Math.atan(n2));
            document.getElementById('brewster6').textContent = brewsterAngle.toFixed(1) + '°';

            // Fresnel equations
            const theta1 = toRad(incAngle);
            const sinTheta2 = Math.sin(theta1) / n2;
            const theta2 = Math.asin(Math.min(1, sinTheta2));

            // p-polarization reflectance
            const rp = Math.pow((n2 * Math.cos(theta1) - Math.cos(theta2)) /
                               (n2 * Math.cos(theta1) + Math.cos(theta2)), 2);
            // s-polarization reflectance
            const rs = Math.pow((Math.cos(theta1) - n2 * Math.cos(theta2)) /
                               (Math.cos(theta1) + n2 * Math.cos(theta2)), 2);

            document.getElementById('rp6').textContent = Math.round(rp * 100) + '%';
            document.getElementById('rs6').textContent = Math.round(rs * 100) + '%';
        }

        function drawDemo6() {
            ctx6.clearRect(0, 0, canvas6.width, canvas6.height);
            const w = canvas6.width, h = canvas6.height;
            const interfaceY = h * 0.5;

            const incAngle = parseInt(document.getElementById('incAngle6').value);
            const n2 = parseInt(document.getElementById('n2_6').value) / 100;

            // Media
            ctx6.fillStyle = 'rgba(100, 180, 255, 0.1)';
            ctx6.fillRect(0, interfaceY, w, h - interfaceY);

            ctx6.strokeStyle = '#64c8ff';
            ctx6.lineWidth = 2;
            ctx6.beginPath();
            ctx6.moveTo(0, interfaceY);
            ctx6.lineTo(w, interfaceY);
            ctx6.stroke();

            ctx6.fillStyle = '#888';
            ctx6.font = '14px Arial';
            ctx6.fillText('空气 (n₁ = 1.0)', 20, interfaceY - 20);
            ctx6.fillText(`玻璃 (n₂ = ${n2.toFixed(2)})`, 20, interfaceY + 30);

            // Normal
            ctx6.strokeStyle = '#555';
            ctx6.setLineDash([5, 5]);
            ctx6.beginPath();
            ctx6.moveTo(w/2, interfaceY - 150);
            ctx6.lineTo(w/2, interfaceY + 150);
            ctx6.stroke();
            ctx6.setLineDash([]);

            const incRad = toRad(incAngle);
            const hitX = w/2, hitY = interfaceY;
            const rayLen = 150;

            // Incident ray
            const incStartX = hitX - rayLen * Math.sin(incRad);
            const incStartY = hitY - rayLen * Math.cos(incRad);

            ctx6.strokeStyle = '#ffcc00';
            ctx6.lineWidth = 4;
            ctx6.beginPath();
            ctx6.moveTo(incStartX, incStartY);
            ctx6.lineTo(hitX, hitY);
            ctx6.stroke();

            // Arrow
            ctx6.fillStyle = '#ffcc00';
            ctx6.beginPath();
            ctx6.moveTo(hitX, hitY);
            ctx6.lineTo(hitX - 10 * Math.sin(incRad - 0.3), hitY - 10 * Math.cos(incRad - 0.3));
            ctx6.lineTo(hitX - 10 * Math.sin(incRad + 0.3), hitY - 10 * Math.cos(incRad + 0.3));
            ctx6.fill();

            // Reflected ray
            const sinTheta2 = Math.sin(incRad) / n2;
            const theta2 = Math.asin(Math.min(1, sinTheta2));

            const rp = Math.pow((n2 * Math.cos(incRad) - Math.cos(theta2)) /
                               (n2 * Math.cos(incRad) + Math.cos(theta2)), 2);
            const rs = Math.pow((Math.cos(incRad) - n2 * Math.cos(theta2)) /
                               (Math.cos(incRad) + n2 * Math.cos(theta2)), 2);

            const refEndX = hitX + rayLen * Math.sin(incRad);
            const refEndY = hitY - rayLen * Math.cos(incRad);

            // s-polarization (reflected)
            ctx6.strokeStyle = `rgba(102, 102, 255, ${0.3 + rs * 0.7})`;
            ctx6.lineWidth = 2 + rs * 4;
            ctx6.beginPath();
            ctx6.moveTo(hitX, hitY);
            ctx6.lineTo(refEndX, refEndY);
            ctx6.stroke();

            // p-polarization (reflected)
            ctx6.strokeStyle = `rgba(255, 102, 102, ${0.3 + rp * 0.7})`;
            ctx6.lineWidth = 2 + rp * 4;
            ctx6.beginPath();
            ctx6.moveTo(hitX, hitY);
            ctx6.lineTo(refEndX - 10, refEndY + 10);
            ctx6.stroke();

            // Refracted ray
            const transEndX = hitX + rayLen * Math.sin(theta2);
            const transEndY = hitY + rayLen * Math.cos(theta2);

            ctx6.strokeStyle = 'rgba(100, 255, 100, 0.7)';
            ctx6.lineWidth = 4;
            ctx6.beginPath();
            ctx6.moveTo(hitX, hitY);
            ctx6.lineTo(transEndX, transEndY);
            ctx6.stroke();

            // Labels
            ctx6.fillStyle = '#ffcc00';
            ctx6.font = '12px Arial';
            ctx6.fillText('入射光', incStartX - 40, incStartY + 20);

            ctx6.fillStyle = '#6666ff';
            ctx6.fillText('s反射', refEndX + 10, refEndY + 20);

            ctx6.fillStyle = '#ff6666';
            ctx6.fillText('p反射', refEndX - 60, refEndY);

            ctx6.fillStyle = '#66ff66';
            ctx6.fillText('折射光', transEndX + 10, transEndY - 10);

            // Brewster indicator
            const brewsterAngle = toDeg(Math.atan(n2));
            if (Math.abs(incAngle - brewsterAngle) < 2) {
                ctx6.fillStyle = '#ff0';
                ctx6.font = 'bold 16px Arial';
                ctx6.fillText('✓ 布儒斯特角！p偏振无反射', w/2 - 100, 30);
            }

            requestAnimationFrame(drawDemo6);
        }

        document.getElementById('incAngle6').addEventListener('input', updateDemo6);
        document.getElementById('n2_6').addEventListener('input', updateDemo6);
        updateDemo6();
        drawDemo6();

        // ============ DEMO 7: Interference ============
        const canvas7 = document.getElementById('canvas7');
        const ctx7 = canvas7.getContext('2d');
        let time7 = 0;

        function updateDemo7() {
            const pol7a = parseInt(document.getElementById('pol7a').value);
            const pol7b = parseInt(document.getElementById('pol7b').value);
            const phase7 = parseInt(document.getElementById('phase7').value);
            const ampRatio = parseInt(document.getElementById('ampRatio7').value) / 100;

            document.getElementById('pol7aVal').textContent = pol7a + '°';
            document.getElementById('pol7bVal').textContent = pol7b + '°';
            document.getElementById('phase7Val').textContent = phase7 + '°';
            document.getElementById('ampRatio7Val').textContent = ampRatio.toFixed(1);

            // Calculate interference
            const polDiff = Math.abs(pol7a - pol7b);
            const parallelFactor = Math.pow(Math.cos(toRad(polDiff)), 2);
            const phaseFactor = Math.cos(toRad(phase7));

            // I = I1 + I2 + 2*sqrt(I1*I2)*cos(phi)*cos^2(theta/2)
            const i1 = 1, i2 = ampRatio * ampRatio;
            const interference = 2 * Math.sqrt(i1 * i2) * phaseFactor * parallelFactor;
            const totalI = i1 + i2 + interference;

            document.getElementById('resultI7').textContent = Math.round(totalI * 100) + '%';

            if (polDiff > 85) {
                document.getElementById('intType7').textContent = '无干涉 (正交)';
            } else if (Math.abs(phase7) < 10 || Math.abs(phase7 - 360) < 10) {
                document.getElementById('intType7').textContent = '相长干涉';
            } else if (Math.abs(phase7 - 180) < 10) {
                document.getElementById('intType7').textContent = ampRatio > 0.9 ? '相消干涉' : '部分相消';
            } else {
                document.getElementById('intType7').textContent = '部分干涉';
            }
        }

        function drawDemo7() {
            ctx7.clearRect(0, 0, canvas7.width, canvas7.height);
            const w = canvas7.width, h = canvas7.height;

            const pol7a = parseInt(document.getElementById('pol7a').value);
            const pol7b = parseInt(document.getElementById('pol7b').value);
            const phase7 = parseInt(document.getElementById('phase7').value);
            const ampRatio = parseInt(document.getElementById('ampRatio7').value) / 100;

            const cy1 = h * 0.25;
            const cy2 = h * 0.5;
            const cy3 = h * 0.75;

            // Wave 1
            ctx7.strokeStyle = '#ff6666';
            ctx7.lineWidth = 2;
            ctx7.beginPath();
            for (let x = 50; x < w - 50; x++) {
                const y = cy1 + Math.sin((x - time7) * 0.05) * 30;
                if (x === 50) ctx7.moveTo(x, y);
                else ctx7.lineTo(x, y);
            }
            ctx7.stroke();
            ctx7.fillStyle = '#ff6666';
            ctx7.font = '12px Arial';
            ctx7.fillText(`光束1 (${pol7a}°)`, 10, cy1 + 5);

            // Wave 2
            ctx7.strokeStyle = '#6666ff';
            ctx7.beginPath();
            for (let x = 50; x < w - 50; x++) {
                const y = cy2 + Math.sin((x - time7) * 0.05 + toRad(phase7)) * 30 * ampRatio;
                if (x === 50) ctx7.moveTo(x, y);
                else ctx7.lineTo(x, y);
            }
            ctx7.stroke();
            ctx7.fillStyle = '#6666ff';
            ctx7.fillText(`光束2 (${pol7b}°, φ=${phase7}°)`, 10, cy2 + 5);

            // Resultant
            const polDiff = Math.abs(pol7a - pol7b);
            const parallelFactor = Math.cos(toRad(polDiff));

            ctx7.strokeStyle = '#ffff00';
            ctx7.lineWidth = 3;
            ctx7.beginPath();
            for (let x = 50; x < w - 50; x++) {
                const wave1 = Math.sin((x - time7) * 0.05);
                const wave2 = Math.sin((x - time7) * 0.05 + toRad(phase7)) * ampRatio * parallelFactor;
                const y = cy3 + (wave1 + wave2) * 30;
                if (x === 50) ctx7.moveTo(x, y);
                else ctx7.lineTo(x, y);
            }
            ctx7.stroke();
            ctx7.fillStyle = '#ffff00';
            ctx7.fillText('合成波', 10, cy3 + 5);

            // Labels
            ctx7.strokeStyle = '#444';
            ctx7.setLineDash([2, 2]);
            ctx7.beginPath();
            ctx7.moveTo(50, 0);
            ctx7.lineTo(50, h);
            ctx7.stroke();
            ctx7.setLineDash([]);

            time7 += 2;
            requestAnimationFrame(drawDemo7);
        }

        document.getElementById('pol7a').addEventListener('input', updateDemo7);
        document.getElementById('pol7b').addEventListener('input', updateDemo7);
        document.getElementById('phase7').addEventListener('input', updateDemo7);
        document.getElementById('ampRatio7').addEventListener('input', updateDemo7);
        updateDemo7();
        drawDemo7();

        // ============ DEMO 8: Optical Activity ============
        const canvas8 = document.getElementById('canvas8');
        const ctx8 = canvas8.getContext('2d');
        let time8 = 0;

        function setDemo8Preset(type) {
            if (type === 'sugar') {
                document.getElementById('alpha8').value = 66;
                document.getElementById('conc8').value = 50;
            } else if (type === 'quartz') {
                document.getElementById('alpha8').value = 22;
                document.getElementById('conc8').value = 100;
            } else if (type === 'fructose') {
                document.getElementById('alpha8').value = -92;
                document.getElementById('conc8').value = 50;
            }
            updateDemo8();
        }

        function updateDemo8() {
            const conc = parseInt(document.getElementById('conc8').value) / 100;
            const path = parseInt(document.getElementById('path8').value) / 10;
            const alpha = parseInt(document.getElementById('alpha8').value);

            document.getElementById('conc8Val').textContent = conc.toFixed(2);
            document.getElementById('path8Val').textContent = path.toFixed(1);
            document.getElementById('alpha8Val').textContent = (alpha >= 0 ? '+' : '') + alpha;

            const rotation = alpha * conc * path;
            document.getElementById('rotation8').textContent = (rotation >= 0 ? '+' : '') + rotation.toFixed(1) + '°';
            document.getElementById('direction8').textContent = rotation >= 0 ? '右旋 (顺时针)' : '左旋 (逆时针)';
        }

        function drawDemo8() {
            ctx8.clearRect(0, 0, canvas8.width, canvas8.height);
            const w = canvas8.width, h = canvas8.height;
            const cy = h / 2;

            const conc = parseInt(document.getElementById('conc8').value) / 100;
            const path = parseInt(document.getElementById('path8').value) / 10;
            const alpha = parseInt(document.getElementById('alpha8').value);
            const rotation = toRad(alpha * conc * path);

            // Container (sample tube)
            const tubeStart = w * 0.25;
            const tubeEnd = w * 0.75;
            const tubeH = 80;

            ctx8.fillStyle = 'rgba(255, 200, 100, 0.2)';
            ctx8.strokeStyle = 'rgba(255, 200, 100, 0.5)';
            ctx8.lineWidth = 2;
            ctx8.beginPath();
            ctx8.rect(tubeStart, cy - tubeH/2, tubeEnd - tubeStart, tubeH);
            ctx8.fill();
            ctx8.stroke();

            ctx8.fillStyle = '#ffcc66';
            ctx8.font = '14px Arial';
            ctx8.textAlign = 'center';
            ctx8.fillText('旋光性溶液', (tubeStart + tubeEnd) / 2, cy - tubeH/2 - 15);

            // Input polarization
            const pSize = 50;
            ctx8.save();
            ctx8.translate(tubeStart - 60, cy);
            ctx8.strokeStyle = '#00ccff';
            ctx8.lineWidth = 3;
            ctx8.beginPath();
            ctx8.moveTo(0, -pSize);
            ctx8.lineTo(0, pSize);
            ctx8.stroke();
            ctx8.fillStyle = '#00ccff';
            ctx8.font = '12px Arial';
            ctx8.textAlign = 'center';
            ctx8.fillText('入射 (0°)', 0, pSize + 20);
            ctx8.restore();

            // Light beam through sample
            ctx8.strokeStyle = '#ffff00';
            ctx8.lineWidth = 2;
            ctx8.beginPath();
            ctx8.moveTo(50, cy);
            ctx8.lineTo(tubeStart, cy);
            ctx8.stroke();

            // Rotating polarization inside tube
            for (let x = tubeStart; x < tubeEnd; x += 20) {
                const progress = (x - tubeStart) / (tubeEnd - tubeStart);
                const angle = rotation * progress;

                ctx8.save();
                ctx8.translate(x, cy);
                ctx8.rotate(angle);
                ctx8.strokeStyle = `rgba(255, 255, 0, ${0.3 + progress * 0.5})`;
                ctx8.lineWidth = 2;
                ctx8.beginPath();
                ctx8.moveTo(0, -15);
                ctx8.lineTo(0, 15);
                ctx8.stroke();
                ctx8.restore();
            }

            // Output beam
            ctx8.strokeStyle = '#ffff00';
            ctx8.lineWidth = 2;
            ctx8.beginPath();
            ctx8.moveTo(tubeEnd, cy);
            ctx8.lineTo(w - 50, cy);
            ctx8.stroke();

            // Output polarization
            ctx8.save();
            ctx8.translate(tubeEnd + 60, cy);
            ctx8.rotate(rotation);
            ctx8.strokeStyle = '#ffcc00';
            ctx8.lineWidth = 3;
            ctx8.beginPath();
            ctx8.moveTo(0, -pSize);
            ctx8.lineTo(0, pSize);
            ctx8.stroke();
            ctx8.restore();

            ctx8.fillStyle = '#ffcc00';
            ctx8.font = '12px Arial';
            ctx8.textAlign = 'center';
            ctx8.fillText(`出射 (${(alpha * conc * path).toFixed(1)}°)`, tubeEnd + 60, cy + pSize + 20);

            // Animated spiral (showing rotation)
            ctx8.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            ctx8.lineWidth = 1;
            ctx8.beginPath();
            for (let t = 0; t <= 1; t += 0.01) {
                const x = tubeStart + (tubeEnd - tubeStart) * t;
                const angle = rotation * t + time8 * 0.05;
                const y = cy + Math.sin(angle) * 20;
                if (t === 0) ctx8.moveTo(x, y);
                else ctx8.lineTo(x, y);
            }
            ctx8.stroke();

            time8++;
            requestAnimationFrame(drawDemo8);
        }

        document.getElementById('conc8').addEventListener('input', updateDemo8);
        document.getElementById('path8').addEventListener('input', updateDemo8);
        document.getElementById('alpha8').addEventListener('input', updateDemo8);
        updateDemo8();
        drawDemo8();

        // ============ DEMO 9: Photoelasticity ============
        const canvas9 = document.getElementById('canvas9');
        const ctx9 = canvas9.getContext('2d');
        let stressPattern9 = 'point';

        function setDemo9Preset(type) {
            stressPattern9 = type;
        }

        function updateDemo9() {
            document.getElementById('stress9Val').textContent = document.getElementById('stress9').value + '%';
            document.getElementById('analyzerAngle9Val').textContent = document.getElementById('analyzerAngle9').value + '°';
        }

        function drawDemo9() {
            ctx9.clearRect(0, 0, canvas9.width, canvas9.height);
            const w = canvas9.width, h = canvas9.height;
            const cx = w / 2, cy = h / 2;

            const stress = parseInt(document.getElementById('stress9').value) / 100;
            const analyzerAngle = parseInt(document.getElementById('analyzerAngle9').value);

            // Background (crossed polarizers = dark)
            ctx9.fillStyle = analyzerAngle === 90 ? '#111' : '#333';
            ctx9.fillRect(0, 0, w, h);

            // Sample area
            const size = 160;
            const imgData = ctx9.createImageData(w, h);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const dx = x - cx;
                    const dy = y - cy;

                    let stressDiff = 0;
                    let stressAngle = 0;

                    if (stressPattern9 === 'point') {
                        // Point load - radial stress pattern
                        const r = Math.sqrt(dx * dx + dy * dy);
                        if (r > 20 && r < size) {
                            stressDiff = stress * 200 / (r + 10);
                            stressAngle = Math.atan2(dy, dx);
                        }
                    } else if (stressPattern9 === 'tension') {
                        // Uniform tension
                        if (Math.abs(dx) < size && Math.abs(dy) < size * 0.6) {
                            stressDiff = stress * 100;
                            stressAngle = 0;
                        }
                    } else if (stressPattern9 === 'bend') {
                        // Bending - linear gradient
                        if (Math.abs(dx) < size && Math.abs(dy) < size * 0.4) {
                            stressDiff = stress * Math.abs(dy) * 2;
                            stressAngle = dy > 0 ? 0 : Math.PI;
                        }
                    } else if (stressPattern9 === 'hole') {
                        // Stress concentration around hole
                        const r = Math.sqrt(dx * dx + dy * dy);
                        const holeR = 30;
                        if (r > holeR && r < size) {
                            const factor = (holeR * holeR) / (r * r);
                            stressDiff = stress * 150 * (1 + factor + factor * Math.cos(2 * Math.atan2(dy, dx)));
                            stressAngle = Math.atan2(dy, dx);
                        }
                    }

                    if (stressDiff > 0) {
                        // Birefringence color calculation
                        const delta = stressDiff * Math.PI / 50;
                        const theta = stressAngle - toRad(analyzerAngle / 2);

                        // Intensity through crossed polarizers
                        const intensity = Math.pow(Math.sin(2 * theta), 2) * Math.pow(Math.sin(delta / 2), 2);

                        // Wavelength-dependent retardation for colors
                        const retardation = stressDiff;

                        let r, g, b;
                        // Michel-Levy color chart approximation
                        const order = retardation / 50;
                        const phase = (order % 1) * 2 * Math.PI;

                        r = Math.floor(128 + 127 * Math.sin(phase));
                        g = Math.floor(128 + 127 * Math.sin(phase + 2 * Math.PI / 3));
                        b = Math.floor(128 + 127 * Math.sin(phase + 4 * Math.PI / 3));

                        const brightness = intensity * 0.8 + 0.2;
                        r = Math.floor(r * brightness);
                        g = Math.floor(g * brightness);
                        b = Math.floor(b * brightness);

                        const idx = (y * w + x) * 4;
                        imgData.data[idx] = r;
                        imgData.data[idx + 1] = g;
                        imgData.data[idx + 2] = b;
                        imgData.data[idx + 3] = 255;
                    }
                }
            }

            ctx9.putImageData(imgData, 0, 0);

            // Draw hole for 'hole' pattern
            if (stressPattern9 === 'hole') {
                ctx9.fillStyle = '#111';
                ctx9.beginPath();
                ctx9.arc(cx, cy, 30, 0, Math.PI * 2);
                ctx9.fill();
            }

            // Labels
            ctx9.fillStyle = '#fff';
            ctx9.font = '14px Arial';
            ctx9.textAlign = 'left';
            ctx9.fillText('起偏器 (0°)', 10, 25);
            ctx9.fillText(`检偏器 (${analyzerAngle}°)`, 10, 45);

            // Pattern label
            const labels = {
                'point': '点载荷',
                'tension': '拉伸应力',
                'bend': '弯曲应力',
                'hole': '圆孔应力集中'
            };
            ctx9.fillStyle = '#64c8ff';
            ctx9.font = '16px Arial';
            ctx9.textAlign = 'center';
            ctx9.fillText(labels[stressPattern9], cx, h - 20);

            requestAnimationFrame(drawDemo9);
        }

        document.getElementById('stress9').addEventListener('input', updateDemo9);
        document.getElementById('analyzerAngle9').addEventListener('input', updateDemo9);
        updateDemo9();
        drawDemo9();

        // ============ DEMO 10: Rayleigh & Mie Scattering ============
        const canvas10 = document.getElementById('canvas10');
        const ctx10 = canvas10.getContext('2d');
        let particleSize10 = 100;
        let observeAngle10 = 90;
        let time10 = 0;

        function setScatterPreset(preset) {
            const presets = {
                'sky': { size: 20, angle: 90 },
                'cloud': { size: 1000, angle: 45 },
                'sunset': { size: 50, angle: 10 },
                'milk': { size: 300, angle: 90 }
            };
            const p = presets[preset];
            document.getElementById('particleSize10').value = p.size;
            document.getElementById('observeAngle10').value = p.angle;
            updateDemo10();
        }

        function updateDemo10() {
            particleSize10 = parseInt(document.getElementById('particleSize10').value);
            observeAngle10 = parseInt(document.getElementById('observeAngle10').value);

            document.getElementById('particleSize10Val').textContent = particleSize10 + 'nm';
            document.getElementById('observeAngle10Val').textContent = observeAngle10 + '°';

            // Determine scattering type
            const sizeParameter = particleSize10 / 500; // normalized to wavelength
            let scatterType = '瑞利散射';
            if (sizeParameter > 0.5) scatterType = '过渡区';
            if (sizeParameter > 1) scatterType = '米氏散射';
            document.getElementById('scatterType10').textContent = scatterType;

            // Polarization degree (simplified model)
            const polarDeg = Math.sin(toRad(observeAngle10)) * (1 - sizeParameter * 0.3);
            document.getElementById('polarDegree10').textContent = Math.round(Math.max(0, Math.min(100, polarDeg * 100))) + '%';
        }

        function drawDemo10() {
            const w = canvas10.width;
            const h = canvas10.height;
            ctx10.clearRect(0, 0, w, h);

            // Background gradient simulating sky color based on particle size
            const sizeParam = particleSize10 / 500;
            let skyR = 50 + sizeParam * 150;
            let skyG = 100 + sizeParam * 100;
            let skyB = 255 - sizeParam * 50;

            // Adjust for observation angle (sunset effect)
            const sunsetFactor = Math.max(0, 1 - observeAngle10 / 90);
            skyR = Math.min(255, skyR + sunsetFactor * 200);
            skyG = Math.min(255, skyG * (1 - sunsetFactor * 0.5));
            skyB = Math.max(50, skyB * (1 - sunsetFactor));

            const grad = ctx10.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, `rgb(${Math.round(skyR)}, ${Math.round(skyG)}, ${Math.round(skyB)})`);
            grad.addColorStop(1, `rgb(${Math.round(skyR * 0.3)}, ${Math.round(skyG * 0.3)}, ${Math.round(skyB * 0.4)})`);
            ctx10.fillStyle = grad;
            ctx10.fillRect(0, 0, w, h);

            // Draw sun
            const sunX = w * 0.8;
            const sunY = h * 0.2 + (90 - observeAngle10) * 2;
            const sunGrad = ctx10.createRadialGradient(sunX, sunY, 0, sunX, sunY, 60);
            sunGrad.addColorStop(0, 'rgba(255, 255, 200, 1)');
            sunGrad.addColorStop(0.3, 'rgba(255, 220, 100, 0.8)');
            sunGrad.addColorStop(1, 'rgba(255, 150, 50, 0)');
            ctx10.fillStyle = sunGrad;
            ctx10.beginPath();
            ctx10.arc(sunX, sunY, 60, 0, Math.PI * 2);
            ctx10.fill();

            // Draw particles
            const numParticles = Math.min(200, 50 + particleSize10 / 10);
            for (let i = 0; i < numParticles; i++) {
                const px = Math.random() * w;
                const py = Math.random() * h;
                const pSize = Math.max(1, particleSize10 / 300 + Math.random() * 2);

                // Color depends on size (Rayleigh = blue scatter, Mie = white)
                const blueShift = Math.max(0, 1 - sizeParam);
                const alpha = 0.3 + Math.random() * 0.4;
                ctx10.fillStyle = `rgba(${200 + blueShift * 55}, ${220 + blueShift * 35}, 255, ${alpha})`;
                ctx10.beginPath();
                ctx10.arc(px, py, pSize, 0, Math.PI * 2);
                ctx10.fill();
            }

            // Draw scattering diagram (polar plot)
            const diagramX = 150;
            const diagramY = h - 120;
            const diagramR = 80;

            // Background circle
            ctx10.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx10.beginPath();
            ctx10.arc(diagramX, diagramY, diagramR + 10, 0, Math.PI * 2);
            ctx10.fill();

            ctx10.strokeStyle = '#444';
            ctx10.lineWidth = 1;
            ctx10.beginPath();
            ctx10.arc(diagramX, diagramY, diagramR, 0, Math.PI * 2);
            ctx10.stroke();

            // Draw scattering pattern
            ctx10.strokeStyle = '#00ff88';
            ctx10.lineWidth = 2;
            ctx10.beginPath();
            for (let angle = 0; angle <= 360; angle += 2) {
                const rad = toRad(angle);
                // Simplified scattering function
                let intensity;
                if (sizeParam < 0.3) {
                    // Rayleigh: (1 + cos²θ) pattern
                    intensity = (1 + Math.pow(Math.cos(rad), 2)) / 2;
                } else {
                    // Mie: forward-peaked pattern
                    const forwardPeak = Math.exp(-Math.pow(angle - 0, 2) / (2000 * sizeParam));
                    intensity = 0.3 + forwardPeak * 0.7;
                }
                const r = diagramR * intensity;
                const x = diagramX + r * Math.cos(rad);
                const y = diagramY - r * Math.sin(rad);
                if (angle === 0) ctx10.moveTo(x, y);
                else ctx10.lineTo(x, y);
            }
            ctx10.closePath();
            ctx10.stroke();

            // Observation angle indicator
            const obsRad = toRad(observeAngle10);
            ctx10.strokeStyle = '#ff6644';
            ctx10.lineWidth = 2;
            ctx10.beginPath();
            ctx10.moveTo(diagramX, diagramY);
            ctx10.lineTo(diagramX + (diagramR + 20) * Math.cos(obsRad), diagramY - (diagramR + 20) * Math.sin(obsRad));
            ctx10.stroke();

            // Labels
            ctx10.fillStyle = '#fff';
            ctx10.font = '12px Arial';
            ctx10.textAlign = 'center';
            ctx10.fillText('散射强度分布', diagramX, diagramY + diagramR + 25);
            ctx10.fillText(`观察角: ${observeAngle10}°`, diagramX, diagramY + diagramR + 40);

            // Legend
            ctx10.fillStyle = '#64c8ff';
            ctx10.font = '14px Arial';
            ctx10.textAlign = 'left';
            ctx10.fillText(`粒径: ${particleSize10}nm`, 20, 30);
            ctx10.fillText(`λ/d ≈ ${(500 / particleSize10).toFixed(1)}`, 20, 50);

            time10++;
            requestAnimationFrame(drawDemo10);
        }

        document.getElementById('particleSize10').addEventListener('input', updateDemo10);
        document.getElementById('observeAngle10').addEventListener('input', updateDemo10);
        updateDemo10();
        drawDemo10();

        // ============ DEMO 11: Stokes & Mueller ============
        const canvas11 = document.getElementById('canvas11');
        const ctx11 = canvas11.getContext('2d');

        // Stokes vectors for different polarization states
        const stokesVectors = {
            'horizontal': [1, 1, 0, 0],
            'vertical': [1, -1, 0, 0],
            'diagonal': [1, 0, 1, 0],
            'antidiagonal': [1, 0, -1, 0],
            'circular_r': [1, 0, 0, 1],
            'circular_l': [1, 0, 0, -1],
            'unpolarized': [1, 0, 0, 0]
        };

        // Mueller matrices for optical elements
        const muellerMatrices = {
            'polarizer_h': [[0.5, 0.5, 0, 0], [0.5, 0.5, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
            'polarizer_v': [[0.5, -0.5, 0, 0], [-0.5, 0.5, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
            'polarizer_45': [[0.5, 0, 0.5, 0], [0, 0, 0, 0], [0.5, 0, 0.5, 0], [0, 0, 0, 0]],
            'qwp': [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1], [0, 0, 1, 0]],
            'hwp': [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, -1]],
            'depolarizer': [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
            'identity': [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
        };

        let currentStokes = 'horizontal';
        let currentMueller = 'polarizer_h';
        let time11 = 0;

        function setStokesInput(type) {
            currentStokes = type;
            updateDemo11();
        }

        function setMuellerElement(type) {
            currentMueller = type;
            updateDemo11();
        }

        function multiplyMuellerStokes(M, S) {
            const result = [0, 0, 0, 0];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i] += M[i][j] * S[j];
                }
            }
            return result;
        }

        function updateDemo11() {
            const Sin = stokesVectors[currentStokes];
            const M = muellerMatrices[currentMueller];
            const Sout = multiplyMuellerStokes(M, Sin);

            document.getElementById('stokesIn11').textContent = `[${Sin.map(v => v.toFixed(1)).join(', ')}]`;
            document.getElementById('stokesOut11').textContent = `[${Sout.map(v => v.toFixed(2)).join(', ')}]`;
        }

        function drawDemo11() {
            const w = canvas11.width;
            const h = canvas11.height;
            ctx11.clearRect(0, 0, w, h);

            const Sin = stokesVectors[currentStokes];
            const M = muellerMatrices[currentMueller];
            const Sout = multiplyMuellerStokes(M, Sin);

            // Draw input polarization (Poincaré sphere projection)
            const sphereX1 = 150;
            const sphereY = h / 2;
            const sphereR = 80;

            // Draw Poincaré sphere (simplified 2D projection)
            ctx11.strokeStyle = '#333';
            ctx11.lineWidth = 1;
            ctx11.beginPath();
            ctx11.arc(sphereX1, sphereY, sphereR, 0, Math.PI * 2);
            ctx11.stroke();

            // Axes
            ctx11.strokeStyle = '#444';
            ctx11.beginPath();
            ctx11.moveTo(sphereX1 - sphereR, sphereY);
            ctx11.lineTo(sphereX1 + sphereR, sphereY);
            ctx11.moveTo(sphereX1, sphereY - sphereR);
            ctx11.lineTo(sphereX1, sphereY + sphereR);
            ctx11.stroke();

            // Input state point
            const inX = sphereX1 + Sin[1] * sphereR * 0.9;
            const inY = sphereY - Sin[2] * sphereR * 0.9;
            ctx11.fillStyle = '#00ccff';
            ctx11.beginPath();
            ctx11.arc(inX, inY, 10, 0, Math.PI * 2);
            ctx11.fill();

            // Draw input wave animation
            ctx11.strokeStyle = '#00ccff';
            ctx11.lineWidth = 2;
            ctx11.beginPath();
            for (let i = 0; i < 60; i++) {
                const t = (i - time11 * 0.1) * 0.1;
                const ex = Sin[0] > 0 ? (Sin[1] >= 0 ? 1 : -1) * Math.sqrt((1 + Sin[1]) / 2) : 0;
                const ey = Sin[0] > 0 ? Math.sqrt((1 - Sin[1]) / 2) : 0;
                const phase = Sin[3] > 0 ? Math.PI / 2 : (Sin[3] < 0 ? -Math.PI / 2 : 0);

                const px = 50 + i * 2;
                const py = sphereY - 120 + Math.sin(t) * 20 * ex;
                if (i === 0) ctx11.moveTo(px, py);
                else ctx11.lineTo(px, py);
            }
            ctx11.stroke();

            // Labels for input
            ctx11.fillStyle = '#00ccff';
            ctx11.font = '16px Arial';
            ctx11.textAlign = 'center';
            ctx11.fillText('入射偏振态', sphereX1, sphereY + sphereR + 30);
            ctx11.font = '12px Arial';
            ctx11.fillText(`S = [${Sin.join(', ')}]`, sphereX1, sphereY + sphereR + 50);

            // Draw Mueller matrix (center)
            const matrixX = w / 2;
            const matrixY = sphereY;
            const cellSize = 35;

            ctx11.fillStyle = 'rgba(100, 200, 255, 0.1)';
            ctx11.fillRect(matrixX - cellSize * 2, matrixY - cellSize * 2, cellSize * 4, cellSize * 4);

            ctx11.strokeStyle = '#64c8ff';
            ctx11.lineWidth = 2;
            ctx11.strokeRect(matrixX - cellSize * 2, matrixY - cellSize * 2, cellSize * 4, cellSize * 4);

            ctx11.fillStyle = '#fff';
            ctx11.font = '12px monospace';
            ctx11.textAlign = 'center';
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const val = M[i][j];
                    const x = matrixX - cellSize * 1.5 + j * cellSize;
                    const y = matrixY - cellSize * 1.5 + i * cellSize + 5;
                    ctx11.fillText(val.toFixed(1), x, y);
                }
            }

            ctx11.fillStyle = '#ffcc00';
            ctx11.font = '14px Arial';
            ctx11.fillText('Mueller矩阵', matrixX, matrixY - cellSize * 2 - 10);

            // Draw output polarization
            const sphereX2 = w - 150;

            ctx11.strokeStyle = '#333';
            ctx11.lineWidth = 1;
            ctx11.beginPath();
            ctx11.arc(sphereX2, sphereY, sphereR, 0, Math.PI * 2);
            ctx11.stroke();

            ctx11.strokeStyle = '#444';
            ctx11.beginPath();
            ctx11.moveTo(sphereX2 - sphereR, sphereY);
            ctx11.lineTo(sphereX2 + sphereR, sphereY);
            ctx11.moveTo(sphereX2, sphereY - sphereR);
            ctx11.lineTo(sphereX2, sphereY + sphereR);
            ctx11.stroke();

            // Output state point
            if (Sout[0] > 0.01) {
                const outX = sphereX2 + (Sout[1] / Sout[0]) * sphereR * 0.9;
                const outY = sphereY - (Sout[2] / Sout[0]) * sphereR * 0.9;
                ctx11.fillStyle = '#ffcc00';
                ctx11.beginPath();
                ctx11.arc(outX, outY, 10, 0, Math.PI * 2);
                ctx11.fill();
            }

            // Draw output wave
            ctx11.strokeStyle = `rgba(255, 204, 0, ${Sout[0]})`;
            ctx11.lineWidth = 2;
            ctx11.beginPath();
            for (let i = 0; i < 60; i++) {
                const t = (i - time11 * 0.1) * 0.1;
                const amp = Math.sqrt(Sout[0]) * 20;
                const px = sphereX2 - 60 + i * 2;
                const py = sphereY - 120 + Math.sin(t) * amp * (Sout[0] > 0 ? (Sout[1] >= 0 ? 1 : -1) : 0);
                if (i === 0) ctx11.moveTo(px, py);
                else ctx11.lineTo(px, py);
            }
            ctx11.stroke();

            // Labels for output
            ctx11.fillStyle = '#ffcc00';
            ctx11.font = '16px Arial';
            ctx11.textAlign = 'center';
            ctx11.fillText('出射偏振态', sphereX2, sphereY + sphereR + 30);
            ctx11.font = '12px Arial';
            ctx11.fillText(`S' = [${Sout.map(v => v.toFixed(2)).join(', ')}]`, sphereX2, sphereY + sphereR + 50);

            // Intensity bar
            ctx11.fillStyle = '#333';
            ctx11.fillRect(sphereX2 - 50, sphereY + sphereR + 70, 100, 15);
            ctx11.fillStyle = '#ffcc00';
            ctx11.fillRect(sphereX2 - 50, sphereY + sphereR + 70, 100 * Sout[0], 15);
            ctx11.fillStyle = '#fff';
            ctx11.font = '10px Arial';
            ctx11.fillText(`透射率: ${(Sout[0] * 100).toFixed(0)}%`, sphereX2, sphereY + sphereR + 100);

            // Arrows
            ctx11.strokeStyle = '#666';
            ctx11.lineWidth = 2;
            ctx11.beginPath();
            ctx11.moveTo(sphereX1 + sphereR + 20, sphereY);
            ctx11.lineTo(matrixX - cellSize * 2 - 20, sphereY);
            ctx11.moveTo(matrixX + cellSize * 2 + 20, sphereY);
            ctx11.lineTo(sphereX2 - sphereR - 20, sphereY);
            ctx11.stroke();

            // Arrow heads
            ctx11.fillStyle = '#666';
            ctx11.beginPath();
            ctx11.moveTo(matrixX - cellSize * 2 - 20, sphereY);
            ctx11.lineTo(matrixX - cellSize * 2 - 30, sphereY - 5);
            ctx11.lineTo(matrixX - cellSize * 2 - 30, sphereY + 5);
            ctx11.fill();
            ctx11.beginPath();
            ctx11.moveTo(sphereX2 - sphereR - 20, sphereY);
            ctx11.lineTo(sphereX2 - sphereR - 30, sphereY - 5);
            ctx11.lineTo(sphereX2 - sphereR - 30, sphereY + 5);
            ctx11.fill();

            time11++;
            requestAnimationFrame(drawDemo11);
        }

        updateDemo11();
        drawDemo11();

    </script>
</body>
</html>
