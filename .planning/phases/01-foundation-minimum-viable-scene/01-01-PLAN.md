---
phase: 01-foundation-minimum-viable-scene
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/isometric.ts
  - src/stores/odysseyWorldStore.ts
  - src/routes/odyssey.index.tsx
  - src/routes/odyssey.index.lazy.tsx
  - src/pages/OdysseyPage.tsx
autonomous: true
requirements:
  - TECH-02
  - TECH-03
  - TECH-04

must_haves:
  truths:
    - "Isometric coordinate conversions are mathematically correct (worldToScreen/screenToWorld round-trip)"
    - "Scene state store manages camera, zoom, beam segments, scene elements, and navigation state"
    - "/odyssey/ route renders without breaking other PolarCraft modules"
  artifacts:
    - path: "src/lib/isometric.ts"
      provides: "Isometric coordinate system utilities"
      exports: ["worldToScreen", "screenToWorld", "screenToWorld_withCamera", "depthSort", "TILE_WIDTH", "TILE_HEIGHT"]
      min_lines: 40
    - path: "src/stores/odysseyWorldStore.ts"
      provides: "Scene state management with composable physics data model"
      exports: ["useOdysseyWorldStore"]
      contains: "subscribeWithSelector"
      min_lines: 80
    - path: "src/pages/OdysseyPage.tsx"
      provides: "Entry point rendering new Odyssey world component"
      min_lines: 5
  key_links:
    - from: "src/routes/odyssey.index.lazy.tsx"
      to: "src/pages/OdysseyPage.tsx"
      via: "lazy route import"
      pattern: "import.*OdysseyPage"
    - from: "src/stores/odysseyWorldStore.ts"
      to: "src/lib/isometric.ts"
      via: "coordinate conversion for camera/navigation"
      pattern: "import.*isometric"
---

<objective>
Build the foundational layer for the Odyssey isometric world: isometric coordinate math utilities, the Zustand scene state store with composable physics data model, and route wiring that cleanly replaces the old odyssey page.

Purpose: Everything else in Phase 1 depends on coordinate math and state management. Getting these right first prevents cascading bugs in scene rendering and click detection.
Output: `isometric.ts` utility module, `odysseyWorldStore.ts` Zustand store, updated route/page files.
</objective>

<execution_context>
@/Users/jili/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jili/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-minimum-viable-scene/01-CONTEXT.md
@.planning/phases/01-foundation-minimum-viable-scene/01-RESEARCH.md

@src/stores/odysseyStore.ts
@src/routes/odyssey.index.tsx
@src/routes/odyssey.index.lazy.tsx
@src/pages/OdysseyPage.tsx
@src/lib/polarization.ts
@src/core/physics/unified/PolarizationState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create isometric coordinate system utilities</name>
  <files>src/lib/isometric.ts</files>
  <action>
Create `src/lib/isometric.ts` with the isometric coordinate math utility module. This is a pure function module with zero dependencies on React or state.

**Constants:**
- `TILE_WIDTH = 128` (pixels)
- `TILE_HEIGHT = 64` (pixels, half width for 2:1 true isometric ratio -- see research Pattern 1)
- `TILE_WIDTH_HALF` and `TILE_HEIGHT_HALF` derived
- `MIN_ZOOM = 0.5`, `MAX_ZOOM = 2.0`
- `DEFAULT_ZOOM = 1.0`

**Functions to implement:**

1. `worldToScreen(worldX: number, worldY: number): { x: number; y: number }` -- Convert world grid coordinates to screen pixel coordinates using standard 2:1 isometric formula: `screenX = (worldX - worldY) * TILE_WIDTH_HALF`, `screenY = (worldX + worldY) * TILE_HEIGHT_HALF`.

2. `screenToWorld(screenX: number, screenY: number): { x: number; y: number }` -- Inverse conversion: `worldX = screenX / TILE_WIDTH + screenY / TILE_HEIGHT`, `worldY = screenY / TILE_HEIGHT - screenX / TILE_WIDTH`.

3. `screenToWorldWithCamera(screenX: number, screenY: number, cameraX: number, cameraY: number, zoom: number): { x: number; y: number }` -- Convert screen coordinates accounting for camera offset and zoom. First reverse the zoom: `unzoomed = screen / zoom`, then add camera offset, then convert to world.

4. `worldToScreenWithCamera(worldX: number, worldY: number, cameraX: number, cameraY: number, zoom: number): { x: number; y: number }` -- Convert world to screen accounting for camera.

5. `depthSort(worldX: number, worldY: number, worldZ: number = 0): number` -- Returns a depth sort key for painter's algorithm. Formula: `(worldX + worldY) + worldZ * 0.01`. Higher values render later (in front). The worldZ multiplier is small because Z is for fine-tuning within a layer, not major depth changes.

6. `clampZoom(zoom: number): number` -- Clamp zoom between MIN_ZOOM and MAX_ZOOM.

7. `tileDistance(ax: number, ay: number, bx: number, by: number): number` -- Manhattan distance in world grid space.

All functions should be exported. Add TypeScript types for `WorldPoint` (`{ x: number; y: number }`) and `ScreenPoint` (`{ x: number; y: number }`) to distinguish between coordinate spaces in function signatures.

Use Chinese comments for the physics/math explanations per project convention.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify the file exports all listed functions by checking `grep -c 'export' src/lib/isometric.ts` shows at least 7 exports.
  </verify>
  <done>
The isometric utility module exists with all coordinate conversion functions, correct 2:1 ratio constants, and TypeScript types for WorldPoint/ScreenPoint. Round-trip conversion `screenToWorld(worldToScreen(x, y))` produces the original values.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Odyssey world store and wire route</name>
  <files>
    src/stores/odysseyWorldStore.ts
    src/routes/odyssey.index.tsx
    src/routes/odyssey.index.lazy.tsx
    src/pages/OdysseyPage.tsx
  </files>
  <action>
**Step A: Create `src/stores/odysseyWorldStore.ts`**

Create a new Zustand store with `subscribeWithSelector` middleware (same pattern as existing `odysseyStore.ts` and `gameStore.ts`). This is a REPLACEMENT for the old `odysseyStore.ts` which was designed for the abandoned 3D portal model. Do NOT modify the old store; create a new one.

**Types to define:**

```typescript
// 场景元素类型 -- composable physics behaviors, not station array
type SceneElementType = 'light-source' | 'polarizer' | 'waveplate' | 'platform' | 'decoration' | 'prism'

interface SceneElement {
  id: string
  type: SceneElementType
  worldX: number
  worldY: number
  worldZ: number  // height level (0 = ground)
  rotation: number // degrees
  properties: Record<string, number | string | boolean> // element-specific
}

interface BeamSegment {
  id: string
  fromX: number
  fromY: number
  fromZ: number
  toX: number
  toY: number
  toZ: number
  // Polarization state stored as Stokes parameters (from PolarizationState)
  stokes: { s0: number; s1: number; s2: number; s3: number }
  // Visual encoding (computed from stokes)
  color: string
  opacity: number
  strokeWidth: number
  shape: 'line' | 'helix' | 'ellipse-markers'
}
```

**Store state:**
- `cameraX: number` (0) -- screen-space camera offset X
- `cameraY: number` (0) -- screen-space camera offset Y
- `zoom: number` (1) -- current zoom level
- `sceneElements: SceneElement[]` (empty) -- all elements in scene
- `beamSegments: BeamSegment[]` (empty) -- computed beam path segments
- `navigationTarget: { x: number; y: number } | null` (null) -- world coords of click target
- `isMoving: boolean` (false) -- whether camera/avatar is animating
- `avatarX: number` (0) -- avatar world position X
- `avatarY: number` (0) -- avatar world position Y
- `sceneLoaded: boolean` (false) -- whether scene data has been initialized

**Actions:**
- `setCamera(x: number, y: number)` -- update camera position
- `setZoom(zoom: number)` -- update zoom with clamping (use `clampZoom` from isometric.ts)
- `navigateTo(worldX: number, worldY: number)` -- set navigation target, isMoving = true
- `onNavigationComplete()` -- clear target, isMoving = false, update avatarX/Y
- `setSceneElements(elements: SceneElement[])` -- bulk load scene elements
- `setBeamSegments(segments: BeamSegment[])` -- update computed beams
- `initScene()` -- load the initial scene layout (hardcoded scene definition with platforms, light source, optical elements, decorations)

The `initScene` action should populate sceneElements with a predefined layout:
- A 7x7 walkable area with platforms at Z=0
- 2-3 raised platforms at Z=1 (multi-level)
- 1 light source
- 2 pre-placed optical elements (polarizer, waveplate)
- Several decorative elements
- 1 initial beam segment (from light source through elements)

Import `clampZoom` from `@/lib/isometric`.

**Step B: Update route files**

Update `src/routes/odyssey.index.tsx`:
- Remove the old `OdysseySearch` type with `unit`/`station` params (those were for the old model)
- Keep it minimal: just `createFileRoute('/odyssey/')({})` with no search validation (isometric world has no URL search params)

Update `src/routes/odyssey.index.lazy.tsx`:
- Keep importing from `@/pages/OdysseyPage` (no change needed if already correct)

Update `src/pages/OdysseyPage.tsx`:
- Replace the import of `OdysseyApp` from `odyssey-v3` with a simple placeholder div that says "Odyssey World Loading..." with a dark background
- This placeholder will be replaced by Plan 02 with the actual OdysseyWorld component
- Add a `useEffect` that calls `useOdysseyWorldStore.getState().initScene()` on mount to initialize scene data
- Add cleanup: reset store on unmount (set sceneLoaded to false)

This ensures the route works, the store initializes, and other modules are not broken.
  </action>
  <verify>
Run `pnpm run build` and confirm no build errors. Navigate to `/odyssey/` in the dev server and confirm it renders the placeholder without console errors. Navigate to `/games/` and `/studio/` to confirm those modules still work. Check that `useOdysseyWorldStore.getState().sceneElements.length > 0` after visiting `/odyssey/` (the initScene populated elements).
  </verify>
  <done>
The new `odysseyWorldStore.ts` exists with composable scene data model (not station array), all camera/navigation/element actions, and a populated initial scene. The route renders at `/odyssey/` without breaking other modules. The old `odysseyStore.ts` remains untouched (other code may reference it).
  </done>
</task>

</tasks>

<verification>
1. `pnpm run build` succeeds with zero type errors
2. `/odyssey/` route renders in the browser
3. Other PolarCraft modules (/games/, /studio/, /calculator/) still function
4. `src/lib/isometric.ts` exports worldToScreen, screenToWorld, and related functions
5. `src/stores/odysseyWorldStore.ts` exports useOdysseyWorldStore with all state and actions
6. Console shows no errors on navigation to/from /odyssey/
</verification>

<success_criteria>
- Isometric coordinate math is available as a reusable utility module
- Scene state store manages camera, zoom, navigation, elements, and beams
- Data model uses composable SceneElement types, not a station/demo array
- /odyssey/ route renders without breaking other modules
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-minimum-viable-scene/01-01-SUMMARY.md`
</output>
