---
phase: 01-foundation-minimum-viable-scene
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/components/odyssey-world/LightBeam.tsx
  - src/components/odyssey-world/BeamParticles.tsx
  - src/components/odyssey-world/BeamGlowFilters.tsx
  - src/components/odyssey-world/hooks/useBeamPhysics.ts
  - src/components/odyssey-world/hooks/useBeamParticles.ts
  - src/components/odyssey-world/IsometricScene.tsx
  - src/stores/odysseyWorldStore.ts
autonomous: true
requirements:
  - PHYS-01
  - PHYS-02
  - PHYS-05

must_haves:
  truths:
    - "A light beam is visible in the scene, rendered as an SVG path with glow effect"
    - "The beam visually changes as it passes through each optical element -- color, width, opacity shift smoothly"
    - "Flowing particles move along the beam path indicating light propagation direction"
    - "Polarization state is encoded: hue maps to orientation angle, shape to polarization type, opacity/width to intensity"
    - "Frame rate holds at 60fps with beam glow filter and particle animation active"
    - "Beam illuminates surfaces it hits -- platform/element color shifts in beam path"
  artifacts:
    - path: "src/components/odyssey-world/LightBeam.tsx"
      provides: "SVG beam rendering with polarization visual encoding"
      min_lines: 60
    - path: "src/components/odyssey-world/BeamParticles.tsx"
      provides: "Flowing particles along beam path via requestAnimationFrame"
      min_lines: 40
    - path: "src/components/odyssey-world/BeamGlowFilters.tsx"
      provides: "Shared SVG filter definitions for beam glow"
      min_lines: 20
    - path: "src/components/odyssey-world/hooks/useBeamPhysics.ts"
      provides: "Bridge between PolarizationState physics engine and visual encoding"
      min_lines: 50
    - path: "src/components/odyssey-world/hooks/useBeamParticles.ts"
      provides: "requestAnimationFrame particle animation loop with cleanup"
      min_lines: 40
  key_links:
    - from: "src/components/odyssey-world/hooks/useBeamPhysics.ts"
      to: "src/core/physics/unified/PolarizationState.ts"
      via: "imports PolarizationState for physics calculation"
      pattern: "import.*PolarizationState"
    - from: "src/components/odyssey-world/hooks/useBeamPhysics.ts"
      to: "src/core/physics/unified/MuellerMatrix.ts"
      via: "imports MuellerMatrix for optical element transformations"
      pattern: "import.*Mueller"
    - from: "src/components/odyssey-world/hooks/useBeamParticles.ts"
      to: "requestAnimationFrame"
      via: "rAF loop with direct DOM mutation for particle positions"
      pattern: "requestAnimationFrame"
    - from: "src/components/odyssey-world/LightBeam.tsx"
      to: "src/components/odyssey-world/BeamGlowFilters.tsx"
      via: "references shared filter ID"
      pattern: "filter.*beam-glow"
    - from: "src/components/odyssey-world/IsometricScene.tsx"
      to: "src/components/odyssey-world/LightBeam.tsx"
      via: "renders beams in layer 3"
      pattern: "LightBeam"
---

<objective>
Implement the polarization-encoded light beam: SVG beam path with glow effect, flowing particles, physics-accurate visual encoding of polarization state (hue for orientation, shape for type, opacity/width for intensity), and surface illumination effect. The beam passes through pre-placed optical elements and visually transforms at each one.

Purpose: The beam IS the core experience -- it's the primary teaching tool. A student must SEE polarization through color, brightness, and shape to discover physics through observation. Without the beam, the scene is just a pretty illustration with nothing to learn from.
Output: Visible, animated, physics-accurate light beam rendering in the isometric scene.
</objective>

<execution_context>
@/Users/jili/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jili/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-minimum-viable-scene/01-CONTEXT.md
@.planning/phases/01-foundation-minimum-viable-scene/01-RESEARCH.md
@.planning/phases/01-foundation-minimum-viable-scene/01-01-SUMMARY.md
@.planning/phases/01-foundation-minimum-viable-scene/01-02-SUMMARY.md

@src/lib/isometric.ts
@src/stores/odysseyWorldStore.ts
@src/core/physics/unified/PolarizationState.ts
@src/core/physics/unified/MuellerMatrix.ts
@src/core/physics/unified/index.ts
@src/components/shared/optical/LightBeamSVG.tsx
@src/lib/polarization.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build beam physics bridge and polarization visual encoding</name>
  <files>
    src/components/odyssey-world/hooks/useBeamPhysics.ts
    src/components/odyssey-world/BeamGlowFilters.tsx
  </files>
  <action>
Create the physics-to-visual bridge that calculates beam segments from scene elements and maps polarization state to visual properties.

**`hooks/useBeamPhysics.ts`:**

This hook connects the existing unified physics engine to the Odyssey scene's visual rendering. It reads scene elements from the store, calculates the beam path through optical elements, and produces `BeamSegment[]` with visual encoding.

**Imports:**
- `PolarizationState` from `@/core/physics/unified/PolarizationState`
- `MuellerMatrix` from `@/core/physics/unified/MuellerMatrix` (for polarizer/waveplate transforms)
- `useOdysseyWorldStore` from `@/stores/odysseyWorldStore`
- `worldToScreen` from `@/lib/isometric`

**Core function `polarizationToVisual(state: PolarizationState)`:**
Returns `BeamVisualProps`:
```typescript
interface BeamVisualProps {
  color: string        // HSL color encoding orientation angle
  opacity: number      // 0-1, maps to intensity
  strokeWidth: number  // thinner = lower intensity (1-6px range)
  shape: 'line' | 'helix' | 'ellipse-markers'  // polarization type
  handedness: 'cw' | 'ccw' | 'none'            // for circular/elliptical
  glowIntensity: number // 0-1, controls glow filter opacity
}
```

Mapping logic (per research Pattern 3 and CONTEXT.md):
- **Orientation angle -> Hue**: `hue = (ellipse.orientationDeg / 180) * 360`. Continuous, NOT the old 4-color discrete mapping. 0 deg = red (hue 0), 45 deg = yellow-green (hue 90), 90 deg = blue-green (hue 180), 135 deg = purple (hue 270), wraps at 180 deg.
- **Ellipticity -> Shape**: `|ellipticityDeg| < 5` -> `'line'` (linear), `|ellipticityDeg| > 40` -> `'helix'` (circular), between -> `'ellipse-markers'` (elliptical).
- **Handedness**: `ellipticityDeg > 2` -> `'cw'`, `< -2` -> `'ccw'`, else `'none'`.
- **Intensity -> Opacity + Width**: `opacity = max(0.05, stokes.s0) * dop`. `strokeWidth = max(1, stokes.s0 * 5)`. At full extinction (s0 ~ 0), beam should be nearly invisible per CONTEXT.md.
- **Color saturation**: `saturation = 75 + dop * 25` (higher DoP = more saturated). Lightness: 55% (bright enough for light backgrounds per pitfall 6).
- **Glow intensity**: `stokes.s0 * dop` -- brighter beam = stronger glow.

**Core function `calculateBeamPath(elements: SceneElement[])`:**
- Find the light source element
- Sort remaining optical elements along the beam direction (by distance from source)
- Start with the light source's initial polarization state (default: linearly polarized at 0 deg, full intensity)
- For each optical element in path order:
  - Create a beam segment from previous position to this element's position
  - Apply the element's Mueller matrix to the polarization state:
    - `'polarizer'`: Use `MuellerMatrix.linearPolarizer(element.properties.angle as number)` -- this is from the existing physics engine
    - `'waveplate'`: Use `MuellerMatrix.waveplate(element.properties.angle as number, element.properties.retardance as number)`
  - Store the resulting polarization state for the next segment
- Add a final beam segment from the last element extending forward (beam continues beyond last element)
- For each segment, call `polarizationToVisual()` to compute visual props
- Return `BeamSegment[]` matching the store's type

**Hook `useBeamPhysics()`:**
- On mount and when sceneElements change, call `calculateBeamPath()`.
- Write results to store via `store.setBeamSegments(segments)`.
- Use `useMemo` for the calculation -- it should be synchronous and well under 16ms for 3-5 elements (per PHYS-02 requirement).
- Return `{ beamSegments }` for direct component access.

**IMPORTANT:** Read the actual PolarizationState class API from `@/core/physics/unified/PolarizationState.ts` before implementing. The `.stokes` property returns `{ s0, s1, s2, s3 }`. The `.ellipse` property returns orientation and ellipticity. The `.dop` property returns degree of polarization. Use these actual APIs, not assumptions.

**IMPORTANT:** Read the actual MuellerMatrix class API from `@/core/physics/unified/MuellerMatrix.ts` before implementing. Find the static factory methods for creating polarizer and waveplate matrices, and the `apply(state)` method for transforming a PolarizationState.

**`BeamGlowFilters.tsx`:**
- A component that renders shared SVG `<defs>` with filter definitions.
- Single `<filter id="beam-glow">` with `feGaussianBlur stdDeviation="1.5"` + `feMerge` (blur behind + source graphic on top). Cap stdDeviation at 1.5 for performance per research pitfall 1.
- Filter region: `x="-40%" y="-40%" width="180%" height="180%"` to avoid clipping the glow.
- A second filter `<filter id="beam-glow-soft">` with `stdDeviation="0.8"` for dimmer beam segments.
- Gradient definitions for beam illumination effect on surfaces.
- This component is rendered once in IsometricScene's `<defs>` (from Plan 02).
  </action>
  <verify>
Run `pnpm run build` -- zero type errors. Check that `useBeamPhysics` hook correctly imports from the unified physics engine (grep for PolarizationState import). Verify `polarizationToVisual` produces distinct visual props for: (a) horizontally polarized (hue ~0, shape='line'), (b) vertically polarized (hue ~180, shape='line'), (c) circularly polarized (shape='helix'). Check that BeamGlowFilters has stdDeviation <= 1.5.
  </verify>
  <done>
The physics-to-visual bridge correctly converts PolarizationState into beam visual properties using continuous HSL encoding. The beam path calculation traces light through optical elements using the existing Mueller matrix engine. SVG glow filter definitions are shared and performance-capped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build beam rendering components with particles and integrate into scene</name>
  <files>
    src/components/odyssey-world/LightBeam.tsx
    src/components/odyssey-world/BeamParticles.tsx
    src/components/odyssey-world/hooks/useBeamParticles.ts
    src/components/odyssey-world/IsometricScene.tsx
    src/stores/odysseyWorldStore.ts
  </files>
  <action>
Create the visual beam rendering components and integrate them into the existing isometric scene.

**`hooks/useBeamParticles.ts`:**
A hook that animates small particles flowing along a beam path using `requestAnimationFrame` and direct DOM mutation (NOT Framer Motion -- per research recommendation, rAF is better for 50-100+ particles).

- Accept `pathPoints: { x: number; y: number }[]` (screen-space beam path points), `speed: number` (0-1, how fast particles flow), `count: number` (number of particles per segment), `color: string`.
- Maintain a `particlesRef` with `{ offset: number }[]` -- each particle's position along the path as a 0-1 fraction.
- In the rAF loop:
  - Calculate `dt` from last frame
  - For each particle: `offset = (offset + dt * speed) % 1`
  - Direct DOM mutation: get the SVG group ref, iterate children, set `cx`/`cy` attributes to the interpolated position along the path
- Helper function `getPointAtOffset(points: Point[], offset: number): Point` -- linear interpolation along the polyline path.
- **CRITICAL cleanup:** Return `svgGroupRef` and the rAF cleanup is in useEffect's return: `cancelAnimationFrame(rafRef.current)`. This prevents memory leaks per research pitfall 4.
- Particles visible: `r=2` circles, opacity 0.6, matching beam color.

**`BeamParticles.tsx`:**
- Component that renders a `<g ref={svgGroupRef}>` with `{count}` `<circle>` elements.
- Uses `useBeamParticles` hook for animation.
- The circles are created in JSX; their positions are updated by the rAF loop (not React).
- React.memo -- this component rarely needs to re-render since animation is rAF-driven.

**`LightBeam.tsx`:**
- The main beam segment renderer. Receives a `BeamSegment` (from store) and renders it as SVG.
- **Beam body:** An SVG `<path>` (or `<line>` for straight segments) with:
  - `stroke` = segment.color (from polarizationToVisual)
  - `strokeWidth` = segment.strokeWidth
  - `opacity` = segment.opacity
  - `filter="url(#beam-glow)"` for the glow effect
  - `strokeLinecap="round"` for soft ends
- **Glow halo:** A second `<path>` rendered BEHIND the main beam with:
  - Same path, 3x strokeWidth, 20% opacity, slightly lighter color
  - This creates the "self-luminous beam with soft halo" effect per CONTEXT.md
- **Shape encoding for non-linear polarization:**
  - If `shape === 'helix'`: Add small spiral/wave markers along the path at regular intervals. Use `<circle>` elements that alternate side-to-side of the beam path, creating a helix-like visual. Animate their side offset to suggest rotation.
  - If `shape === 'ellipse-markers'`: Add small ellipse shapes along the path at regular intervals, tilted to indicate the ellipse orientation.
  - If `shape === 'line'`: No additional markers (straight beam).
- **Continuous transformation (CONTEXT.md):** Where two adjacent segments meet (at an optical element), the beam transitions smoothly. Use the SVG path to curve slightly at the junction point rather than making a hard color change. Alternatively, overlap the end of one segment with the start of the next by a few pixels with a gradient blend.
- **Full extinction:** If `opacity < 0.05`, don't render the segment at all (beam disappears per CONTEXT.md).
- **Illumination effect (CONTEXT.md):** Each beam segment emits a subtle "light zone" -- render a very low-opacity (5-8%) colored rectangle/ellipse beneath the beam path, tinted with the beam's color. This creates the effect of the beam illuminating the surface below it. The illumination follows the beam's color, so it changes as polarization changes.
- Renders `<BeamParticles>` as a child with matching path, speed proportional to intensity, particle count 8-12 per segment.

**Integration into `IsometricScene.tsx`:**
- Import `BeamGlowFilters` and render it inside the existing `<defs>` section.
- In Layer 3 (beams layer), map over `beamSegments` from the store and render a `<LightBeam>` for each.
- Import and call `useBeamPhysics()` in the component (or in OdysseyWorld.tsx) to trigger beam calculation on mount.

**Update `stores/odysseyWorldStore.ts`:**
- In the `initScene()` action, ensure the light source element has initial properties: `{ angle: 0, intensity: 1, polarization: 'linear' }`.
- Ensure the polarizer element has: `{ angle: 45 }` (45 degrees -- so the beam visually changes color when passing through it).
- Ensure the waveplate element has: `{ angle: 22.5, retardance: 90 }` (quarter-wave plate at 22.5 deg -- converts to circular polarization, so the beam shape changes to helix after passing through it).
- This setup demonstrates all three encoding dimensions in a single scene: color change (polarizer rotates orientation), shape change (waveplate creates circular polarization), and intensity change (polarizer reduces intensity by cos^2).

**Beam path geometry in isometric space:**
- Beam segments are defined in world coordinates (from store).
- Convert to screen coordinates using `worldToScreen()` for SVG rendering.
- The beam path between two world points is a straight line in screen space (no perspective correction needed for 2D isometric).
- For multi-level beams (crossing Z levels), add a vertical offset: `screenY -= worldZ * 32` (32px per Z level).
  </action>
  <verify>
Run `pnpm run build` -- zero errors. Open `/odyssey/` in dev server:
1. See a visible light beam emanating from the light source
2. The beam passes through the polarizer -- color changes (hue shift visible)
3. The beam passes through the waveplate -- shape changes to helix pattern (circular polarization)
4. Small particles flow along the beam path in the propagation direction
5. A subtle colored illumination is visible on surfaces beneath the beam
6. The glow effect is visible but not overwhelming on the bright background
7. Open DevTools Performance tab: run a 5-second recording while the scene is visible. Confirm:
   - Frame rate stays at or near 60fps
   - No long frames (>16ms) caused by SVG filter recalculation
   - rAF particle animation runs smoothly
8. Navigate away from /odyssey/ and back 5 times -- check Memory tab for no monotonic heap growth (pitfall 4)
9. Console has no errors
  </verify>
  <done>
A polarization-encoded light beam is visible in the isometric scene, passing through a polarizer and quarter-wave plate. The beam's color shifts (orientation encoding), shape changes from line to helix (linear to circular polarization encoding), and intensity changes (cos^2 law visible in opacity/width). Flowing particles indicate propagation direction. The beam has a soft glow halo visible on the bright background. Surfaces beneath the beam show subtle illumination tinting. Performance holds at 60fps with beam filters and particle animation active. No memory leaks on repeated navigation.
  </done>
</task>

</tasks>

<verification>
1. `pnpm run build` succeeds
2. Light beam visible in the isometric scene with glow effect
3. Beam color changes after passing through polarizer (orientation hue encoding)
4. Beam shape changes after passing through waveplate (circular polarization = helix)
5. Beam intensity decreases after polarizer (cos^2 law -- thinner + more transparent)
6. Flowing particles move along beam path
7. Subtle illumination effect visible on surfaces beneath beam
8. 60fps maintained with beam rendering active (DevTools Performance)
9. No memory leaks on /odyssey/ navigation cycle (DevTools Memory)
10. Beam responds within <16ms when scene state changes (PHYS-02)
</verification>

<success_criteria>
- The beam IS the visual centerpiece -- clearly visible, colorful, animated on the bright background
- Polarization is visually encoded through continuous hue (orientation), shape (linear/circular/elliptical), and opacity+width (intensity)
- Physics calculations use the existing unified engine (PolarizationState, MuellerMatrix) -- not hand-rolled math
- Particle flow uses requestAnimationFrame with proper cleanup -- no Framer Motion for many particles
- SVG glow filter stdDeviation capped at 1.5 for performance
- Full extinction (0 intensity) = beam disappears
- 60fps on desktop throughout
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-minimum-viable-scene/01-03-SUMMARY.md`
</output>
