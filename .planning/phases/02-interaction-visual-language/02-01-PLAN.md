---
phase: 02-interaction-visual-language
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/odysseyWorldStore.ts
  - src/lib/isometric.ts
  - src/components/odyssey-world/hooks/useElementDrag.ts
  - src/components/odyssey-world/hooks/useElementRotation.ts
  - src/components/odyssey-world/hooks/useElementSelection.ts
  - src/components/odyssey-world/hooks/useBeamPreview.ts
  - src/components/odyssey-world/hooks/useBeamPhysics.ts
autonomous: true
requirements: [INTR-01, INTR-02, INTR-04]

must_haves:
  truths:
    - "Store has granular element CRUD actions (updateElement, addElement, removeElement) that trigger beam recalculation"
    - "Pointer events convert correctly from browser viewport to isometric world coordinates through the camera transform"
    - "Dragged elements magnetically snap to the nearest beam path position within a configurable radius"
    - "Click-vs-drag differentiation prevents navigation when manipulating elements"
    - "Rotation hook computes angle via atan2 from element center, supports both drag and scroll wheel input"
    - "Ghost beam preview calculates tentative beam path without updating the main store"
  artifacts:
    - path: "src/stores/odysseyWorldStore.ts"
      provides: "Granular element CRUD actions, selection/hover state, interaction mode tracking"
      contains: "updateElement"
    - path: "src/lib/isometric.ts"
      provides: "snapToBeamPath projection and quantization utility"
      contains: "snapToBeamPath"
    - path: "src/components/odyssey-world/hooks/useElementDrag.ts"
      provides: "Pointer event drag with setPointerCapture, coordinate conversion, snap"
      contains: "useElementDrag"
    - path: "src/components/odyssey-world/hooks/useElementRotation.ts"
      provides: "atan2 rotation via drag handle + scroll wheel with throttled physics update"
      contains: "useElementRotation"
    - path: "src/components/odyssey-world/hooks/useElementSelection.ts"
      provides: "Click-to-select, hover tracking, click-vs-drag differentiation"
      contains: "useElementSelection"
    - path: "src/components/odyssey-world/hooks/useBeamPreview.ts"
      provides: "Ghost beam path calculation from tentative element positions"
      contains: "useBeamPreview"
  key_links:
    - from: "src/components/odyssey-world/hooks/useElementDrag.ts"
      to: "src/stores/odysseyWorldStore.ts"
      via: "updateElement action on pointerup (drop)"
      pattern: "updateElement.*worldX"
    - from: "src/components/odyssey-world/hooks/useElementRotation.ts"
      to: "src/stores/odysseyWorldStore.ts"
      via: "updateElement action on rotation commit"
      pattern: "updateElement.*rotation"
    - from: "src/components/odyssey-world/hooks/useBeamPreview.ts"
      to: "src/components/odyssey-world/hooks/useBeamPhysics.ts"
      via: "reuses calculateBeamPath function for ghost preview"
      pattern: "calculateBeamPath"
---

<objective>
Build the interaction foundation: extend the Zustand store with granular element CRUD, selection/hover state, and interaction mode tracking. Create interaction hooks for drag-and-drop (with magnetic beam snap), rotation (drag handle + scroll wheel), selection (click-vs-drag differentiation), and ghost beam preview.

Purpose: All subsequent Phase 2 plans depend on this foundation -- UI components need these hooks and store actions to wire interaction behavior.
Output: Extended store, 4 new hooks, extended isometric utilities. No visual changes yet -- this is the plumbing.
</objective>

<execution_context>
@/Users/jili/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jili/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interaction-visual-language/02-RESEARCH.md

# Phase 1 built the store and hooks these extend
@src/stores/odysseyWorldStore.ts
@src/lib/isometric.ts
@src/components/odyssey-world/hooks/useBeamPhysics.ts
@src/components/odyssey-world/hooks/useClickToMove.ts
@src/components/odyssey-world/hooks/useIsometricCamera.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend store with element CRUD, selection state, and interaction tracking</name>
  <files>
    src/stores/odysseyWorldStore.ts
    src/lib/isometric.ts
  </files>
  <action>
**Store extensions (`odysseyWorldStore.ts`):**

Add new state fields:
- `selectedElementId: string | null` -- currently selected element ID
- `hoveredElementId: string | null` -- currently hovered element ID
- `interactionMode: 'navigate' | 'drag' | 'rotate' | 'idle'` -- current pointer interaction mode
- `dragPreviewPos: { worldX: number; worldY: number } | null` -- tentative position during drag (for ghost beam)

Add new actions:
- `updateElement: (id: string, patch: Partial<SceneElement>) => void` -- patches a single element by ID, creates new `sceneElements` array reference to trigger `useBeamPhysics` recalculation
- `addElement: (element: SceneElement) => void` -- appends element to `sceneElements`
- `removeElement: (id: string) => void` -- filters element from `sceneElements`
- `selectElement: (id: string | null) => void` -- sets `selectedElementId`
- `hoverElement: (id: string | null) => void` -- sets `hoveredElementId`
- `setInteractionMode: (mode: 'navigate' | 'drag' | 'rotate' | 'idle') => void`
- `setDragPreviewPos: (pos: { worldX: number; worldY: number } | null) => void`

Implementation note for `updateElement`: Use `map` to create new array reference (do NOT mutate in place). The existing `useBeamPhysics` subscribes to `sceneElements` via `useOdysseyWorldStore((s) => s.sceneElements)` -- a new array reference triggers recalculation automatically.

**Isometric utilities extension (`isometric.ts`):**

Add `snapToBeamPath(worldX: number, worldY: number, beamSegments: BeamSegment[], snapRadius?: number): { x: number; y: number } | null`:
- For each beam segment, project the point onto the segment line using parametric projection (clamp t to [0,1])
- Calculate perpendicular distance from point to projection
- If distance < snapRadius (default 1.5 world units), return the projected point quantized to nearest 0.5 grid units
- Return the closest snap point across all segments, or null if none within radius
- Import `BeamSegment` type from the store file

Also add `worldToScreenWithCamera(worldX: number, worldY: number, worldZ: number, cameraX: number, cameraY: number, zoom: number): { x: number; y: number }` if not already present -- needed by rotation hook to find element center in screen space.
  </action>
  <verify>
`pnpm run build` passes with zero errors. The new store actions and isometric utilities are exported and type-safe. Verify `updateElement` creates a new array reference (check implementation uses `.map()`).
  </verify>
  <done>
Store has `updateElement`, `addElement`, `removeElement`, `selectElement`, `hoverElement`, `setInteractionMode`, `setDragPreviewPos` actions. Isometric module exports `snapToBeamPath` and `worldToScreenWithCamera`. All type-safe, build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create interaction hooks (drag, rotation, selection, beam preview)</name>
  <files>
    src/components/odyssey-world/hooks/useElementDrag.ts
    src/components/odyssey-world/hooks/useElementRotation.ts
    src/components/odyssey-world/hooks/useElementSelection.ts
    src/components/odyssey-world/hooks/useBeamPreview.ts
  </files>
  <action>
**useElementDrag.ts:**
- Parameters: `elementId: string`, `containerRef: RefObject<HTMLDivElement>`, `cameraX: MotionValue<number>`, `cameraY: MotionValue<number>`, `zoom: MotionValue<number>`
- Returns: `{ onPointerDown, onPointerMove, onPointerUp, isDragging: boolean, snapPos: { x: number; y: number } | null }`
- On `pointerdown`: record start position, call `(e.target as Element).setPointerCapture(e.pointerId)`, call `e.stopPropagation()` to prevent click-to-move
- On `pointermove`: if distance from start > DRAG_THRESHOLD (5px), enter drag mode via `setInteractionMode('drag')`. Convert pointer to world coordinates using `screenToWorldWithCamera(e.clientX - rect.left, e.clientY - rect.top, cameraX.get(), cameraY.get(), zoom.get())`. Call `snapToBeamPath()` with current beam segments from store. Store snapped position in `useRef` and update `dragPreviewPos` in store (throttled -- only if snap point changed)
- On `pointerup`: if was dragging AND snap position exists, call `updateElement(elementId, { worldX: snap.x, worldY: snap.y })`. If was dragging but no snap (dragged off beam path), call `removeElement(elementId)`. Reset interaction mode. Release pointer capture
- Use `useRef` for intermediate drag state (never React state for per-frame tracking)

**useElementRotation.ts:**
- Parameters: `elementId: string`, `containerRef: RefObject<HTMLDivElement>`, `cameraX: MotionValue<number>`, `cameraY: MotionValue<number>`, `zoom: MotionValue<number>`
- Returns: `{ onRotatePointerDown, onRotatePointerMove, onRotatePointerUp, onWheel, isRotating: boolean, currentAngle: number }`
- Drag handle rotation: On pointerdown on the rotation handle, record initial angle. On pointermove, compute angle via `atan2(pointerY - elementScreenY, pointerX - elementScreenX) * 180 / Math.PI`. Apply delta from initial angle. Throttle store updates to changes > 0.5 degrees (PHYSICS_THRESHOLD_DEG constant). Call `updateElement(elementId, { rotation: newAngle })` on each threshold crossing (real-time beam update during rotation per user decision)
- Scroll wheel rotation: On `wheel` event when element is selected, `e.preventDefault()` + `e.stopPropagation()` (prevent camera zoom). Compute angle delta: 2 degrees per scroll tick (adjustable). Call `updateElement(elementId, { rotation: currentRotation + delta })`
- Also update the element's `properties.transmissionAxis` or `properties.fastAxis` to match `rotation` (polarizer uses transmissionAxis, waveplate uses fastAxis)

**useElementSelection.ts:**
- Parameters: `elementId: string`
- Returns: `{ onPointerDown, onPointerUp, isSelected: boolean, isHovered: boolean, onPointerEnter, onPointerLeave }`
- Selection: If pointerup without drag (distance < DRAG_THRESHOLD), call `selectElement(elementId)`. If clicking empty space (handled at scene level), call `selectElement(null)`
- Hover: `onPointerEnter` calls `hoverElement(elementId)`, `onPointerLeave` calls `hoverElement(null)`
- Reads `selectedElementId` and `hoveredElementId` from store via selectors

**useBeamPreview.ts:**
- Parameters: none (reads from store)
- Returns: `{ previewSegments: BeamSegment[] | null }`
- Reads `dragPreviewPos` and `sceneElements` from store
- When `dragPreviewPos` is not null, creates a tentative copy of `sceneElements` with the dragged element's position replaced, then calls `calculateBeamPath(tentativeElements)` (extract this function from `useBeamPhysics.ts` -- make it a standalone exported function if not already)
- Uses `useMemo` with `[dragPreviewPos, sceneElements]` dependencies
- Returns null when not dragging
- NOTE: If `calculateBeamPath` is currently defined inside `useBeamPhysics` hook, extract it to a standalone export so both hooks can use it. Do NOT duplicate the physics calculation logic.
  </action>
  <verify>
`pnpm run build` passes. All four hooks export correctly and have proper TypeScript types. Verify `useBeamPreview` shares the `calculateBeamPath` function with `useBeamPhysics` (no duplicated physics logic).
  </verify>
  <done>
Four interaction hooks created: `useElementDrag` (pointer capture + snap), `useElementRotation` (atan2 drag + scroll wheel), `useElementSelection` (click-vs-drag + hover), `useBeamPreview` (ghost beam calculation). All hooks use `useRef` for per-frame state, store updates via granular actions, `setPointerCapture` for reliable tracking. `calculateBeamPath` is a shared standalone function. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm run build` -- zero TypeScript errors
2. Store actions `updateElement`, `addElement`, `removeElement` produce new array references
3. `snapToBeamPath` returns correct projection (unit testable but not required for this plan)
4. All hooks properly cleanup pointer capture and refs on unmount
5. `calculateBeamPath` is shared between `useBeamPhysics` and `useBeamPreview` (single source of truth)
</verification>

<success_criteria>
- Store extended with all interaction state and CRUD actions
- 4 interaction hooks created with proper TypeScript signatures
- Isometric module has beam path snapping utility
- Build passes, no duplicated physics logic
</success_criteria>

<output>
After completion, create `.planning/phases/02-interaction-visual-language/02-01-SUMMARY.md`
</output>
