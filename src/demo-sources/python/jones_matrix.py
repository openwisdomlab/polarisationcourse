#!/usr/bin/env python3
"""
Jones矩阵演示 (Jones Matrix Demonstration)
==========================================

完整的Jones矩阵偏振光学演示程序，包含Jones矢量、Jones矩阵计算、
偏振态变换可视化以及Poincare球3D显示。

物理原理 (Physical Principles):
------------------------------
1. **Jones矢量** (Jones Vector):
   描述完全相干偏振光的电场振幅和相位。

   E = [Ex, Ey]^T = [|Ex|e^(iφx), |Ey|e^(iφy)]^T

   常见偏振态:
   - 水平偏振 (H): |H⟩ = [1, 0]^T
   - 垂直偏振 (V): |V⟩ = [0, 1]^T
   - 45°偏振 (D):  |D⟩ = 1/√2 [1, 1]^T
   - -45°偏振(A):  |A⟩ = 1/√2 [1, -1]^T
   - 右圆偏振(R):  |R⟩ = 1/√2 [1, -i]^T
   - 左圆偏振(L):  |L⟩ = 1/√2 [1, i]^T

2. **Jones矩阵** (Jones Matrix):
   2×2复数矩阵，描述光学元件对偏振态的变换。

   E_out = J · E_in

   常见Jones矩阵:
   - 线偏振片(θ): J_pol(θ) = [[cos²θ, sinθcosθ], [sinθcosθ, sin²θ]]
   - λ/4波片:     J_QWP = [[1, 0], [0, -i]]  (快轴沿x)
   - λ/2波片:     J_HWP = [[1, 0], [0, -1]]  (快轴沿x)
   - 旋转器(θ):   J_rot = [[cosθ, -sinθ], [sinθ, cosθ]]

3. **Stokes参数** (Stokes Parameters):
   描述偏振态的实数参数，用于Poincare球表示。

   S0 = |Ex|² + |Ey|²          (总强度)
   S1 = |Ex|² - |Ey|²          (水平-垂直)
   S2 = 2·Re(Ex·Ey*)           (±45°)
   S3 = 2·Im(Ex·Ey*)           (圆偏振)

4. **Poincare球** (Poincare Sphere):
   三维球面上的点表示偏振态:
   - 赤道: 线偏振
   - 北极: 右圆偏振
   - 南极: 左圆偏振
   - 其他: 椭圆偏振

应用场景 (Applications):
----------------------
1. **光纤通信**: 偏振模色散补偿、偏振复用
2. **液晶显示器**: LCD偏振调制、3D显示技术
3. **光学隔离器**: 激光器保护、防反射设计
4. **偏振测量**: 椭偏仪、偏振成像

依赖库 (Dependencies):
--------------------
pip install numpy matplotlib

使用方法 (Usage):
---------------
python jones_matrix.py

作者: PolarCraft Team (Generated by Claude)
日期: 2026-01-14
许可: MIT License
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, RadioButtons, Button
from matplotlib.patches import FancyArrowPatch, Circle, Ellipse, Rectangle
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d import proj3d
import mpl_toolkits.mplot3d.art3d as art3d


# ============================================================================
# 颜色主题 (Color Theme)
# ============================================================================
COLORS = {
    'background': '#0f172a',      # 深蓝背景
    'panel': '#1e293b',           # 面板背景
    'cyan': '#22d3ee',            # 青色 - 蓝光/短波
    'pink': '#f472b6',            # 粉色 - 红光/长波
    'green': '#10b981',           # 绿色 - 中间
    'yellow': '#fbbf24',          # 黄色 - 强调
    'orange': '#ffaa00',          # 橙色 - 输入
    'purple': '#a78bfa',          # 紫色 - 椭圆偏振
    'white': '#f8fafc',           # 白色文字
    'gray': '#94a3b8',            # 灰色次要
    'slate': '#334155',           # 深灰色
}


# ============================================================================
# Jones矢量类 (Jones Vector Class)
# ============================================================================

class JonesVector:
    """
    Jones矢量类

    表示完全相干偏振光的电场矢量。

    属性:
        Ex (complex): x分量
        Ey (complex): y分量

    Jones Vector Representation:
        E = [Ex, Ey]^T = [|Ex|·e^(iφx), |Ey|·e^(iφy)]^T
    """

    def __init__(self, Ex, Ey):
        """
        初始化Jones矢量

        参数:
            Ex: x分量 (复数)
            Ey: y分量 (复数)
        """
        self.Ex = complex(Ex)
        self.Ey = complex(Ey)

    @classmethod
    def horizontal(cls):
        """水平偏振 |H⟩ = [1, 0]^T"""
        return cls(1, 0)

    @classmethod
    def vertical(cls):
        """垂直偏振 |V⟩ = [0, 1]^T"""
        return cls(0, 1)

    @classmethod
    def diagonal(cls):
        """45°偏振 |D⟩ = 1/√2·[1, 1]^T"""
        return cls(1/np.sqrt(2), 1/np.sqrt(2))

    @classmethod
    def antidiagonal(cls):
        """-45°偏振 |A⟩ = 1/√2·[1, -1]^T"""
        return cls(1/np.sqrt(2), -1/np.sqrt(2))

    @classmethod
    def right_circular(cls):
        """右圆偏振 |R⟩ = 1/√2·[1, -i]^T"""
        return cls(1/np.sqrt(2), -1j/np.sqrt(2))

    @classmethod
    def left_circular(cls):
        """左圆偏振 |L⟩ = 1/√2·[1, i]^T"""
        return cls(1/np.sqrt(2), 1j/np.sqrt(2))

    @classmethod
    def linear(cls, angle_deg):
        """
        任意角度线偏振

        E = [cos(θ), sin(θ)]^T

        参数:
            angle_deg: 偏振角度(度)
        """
        theta = np.radians(angle_deg)
        return cls(np.cos(theta), np.sin(theta))

    @classmethod
    def elliptical(cls, a, b, angle_deg, handedness='right'):
        """
        椭圆偏振

        参数:
            a: 长半轴
            b: 短半轴
            angle_deg: 长轴角度(度)
            handedness: 'right'或'left'
        """
        theta = np.radians(angle_deg)
        chi = np.arctan(b / (a + 1e-10))  # 椭圆度角

        if handedness == 'left':
            chi = -chi

        # Jones矢量表达式
        Ex = np.cos(chi) * np.cos(theta) - 1j * np.sin(chi) * np.sin(theta)
        Ey = np.cos(chi) * np.sin(theta) + 1j * np.sin(chi) * np.cos(theta)

        return cls(Ex, Ey)

    def normalize(self):
        """
        归一化Jones矢量

        |E|² = 1

        返回:
            归一化后的新JonesVector对象
        """
        norm = self.intensity()
        if norm > 1e-10:
            return JonesVector(self.Ex / np.sqrt(norm), self.Ey / np.sqrt(norm))
        return JonesVector(0, 0)

    def intensity(self):
        """
        计算光强

        I = |Ex|² + |Ey|²

        返回:
            光强(float)
        """
        return np.abs(self.Ex)**2 + np.abs(self.Ey)**2

    def to_array(self):
        """转换为numpy数组"""
        return np.array([self.Ex, self.Ey], dtype=complex)

    def phase_difference(self):
        """
        计算x和y分量的相位差

        Δφ = φy - φx

        返回:
            相位差(弧度)
        """
        return np.angle(self.Ey) - np.angle(self.Ex)

    def classify(self, tolerance=0.05):
        """
        分类偏振态

        返回:
            (type, params) - 类型和参数
            type: 'linear', 'circular-r', 'circular-l', 'elliptical'
            params: 取决于类型的额外参数
        """
        # 归一化
        norm = self.intensity()
        if norm < 1e-10:
            return ('linear', {'angle': 0})

        Ex_n = self.Ex / np.sqrt(norm)
        Ey_n = self.Ey / np.sqrt(norm)

        # 相位差
        phase_diff = np.angle(Ey_n) - np.angle(Ex_n)
        phase_diff = (phase_diff + np.pi) % (2 * np.pi) - np.pi

        # 振幅比
        amp_ratio = np.abs(Ey_n) / (np.abs(Ex_n) + 1e-10)

        # 判断线偏振: 相位差 ≈ 0 或 ≈ π
        if abs(phase_diff) < tolerance or abs(abs(phase_diff) - np.pi) < tolerance:
            angle_rad = np.arctan2(np.real(Ey_n), np.real(Ex_n))
            angle_deg = np.degrees(angle_rad) % 180
            return ('linear', {'angle': angle_deg})

        # 判断圆偏振: |Ex| ≈ |Ey| 且 相位差 ≈ ±π/2
        if abs(amp_ratio - 1) < tolerance:
            if abs(abs(phase_diff) - np.pi/2) < tolerance:
                if phase_diff < 0:
                    return ('circular-r', {'handedness': 'right'})
                else:
                    return ('circular-l', {'handedness': 'left'})

        # 椭圆偏振
        # 计算椭圆参数
        stokes = self.to_stokes()
        chi = 0.5 * np.arcsin(stokes[3] / (stokes[0] + 1e-10))  # 椭圆度角
        psi = 0.5 * np.arctan2(stokes[2], stokes[1])  # 方位角

        return ('elliptical', {
            'chi': np.degrees(chi),
            'psi': np.degrees(psi),
            'handedness': 'right' if phase_diff < 0 else 'left'
        })

    def to_stokes(self):
        """
        转换为Stokes参数

        S0 = |Ex|² + |Ey|²  (总强度)
        S1 = |Ex|² - |Ey|²  (水平-垂直线偏振)
        S2 = 2·Re(Ex·Ey*)   (±45°线偏振)
        S3 = 2·Im(Ex·Ey*)   (圆偏振)

        返回:
            [S0, S1, S2, S3] numpy数组
        """
        Ex, Ey = self.Ex, self.Ey

        S0 = np.abs(Ex)**2 + np.abs(Ey)**2
        S1 = np.abs(Ex)**2 - np.abs(Ey)**2
        S2 = 2 * np.real(Ex * np.conj(Ey))
        S3 = 2 * np.imag(Ex * np.conj(Ey))

        return np.array([S0, S1, S2, S3])

    def to_poincare(self):
        """
        转换为Poincare球坐标

        归一化Stokes参数 (s1, s2, s3) = (S1/S0, S2/S0, S3/S0)

        返回:
            (s1, s2, s3) - Poincare球上的坐标
        """
        stokes = self.to_stokes()
        S0 = stokes[0]

        if S0 < 1e-10:
            return (0, 0, 0)

        return (stokes[1]/S0, stokes[2]/S0, stokes[3]/S0)

    def __repr__(self):
        return f"JonesVector(Ex={self.Ex:.4f}, Ey={self.Ey:.4f})"


# ============================================================================
# Jones矩阵库 (Jones Matrix Library)
# ============================================================================

def jones_polarizer(theta_deg):
    """
    线偏振片的Jones矩阵

    J_pol(θ) = [[cos²θ, sinθcosθ],
                [sinθcosθ, sin²θ]]

    透射轴与x轴夹角为θ

    参数:
        theta_deg: 透射轴角度(度)

    返回:
        2×2 Jones矩阵
    """
    theta = np.radians(theta_deg)
    c = np.cos(theta)
    s = np.sin(theta)

    return np.array([
        [c**2, s*c],
        [s*c, s**2]
    ], dtype=complex)


def jones_quarter_waveplate(fast_axis_deg):
    """
    λ/4波片的Jones矩阵

    相位延迟: Δφ = π/2 (90°)

    快轴沿x时:
        J_QWP = [[1, 0],
                 [0, -i]]

    旋转后:
        J = R(-θ) · J_QWP · R(θ)

    参数:
        fast_axis_deg: 快轴角度(度)

    返回:
        2×2 Jones矩阵
    """
    # 快轴沿x的矩阵
    M0 = np.array([[1, 0], [0, -1j]], dtype=complex)

    # 旋转到指定角度
    theta = np.radians(fast_axis_deg)
    R = rotation_matrix(theta)
    R_inv = rotation_matrix(-theta)

    return R_inv @ M0 @ R


def jones_half_waveplate(fast_axis_deg):
    """
    λ/2波片的Jones矩阵

    相位延迟: Δφ = π (180°)

    快轴沿x时:
        J_HWP = [[1, 0],
                 [0, -1]]

    旋转效果: 输出角度 = 2·快轴角度 - 输入角度

    参数:
        fast_axis_deg: 快轴角度(度)

    返回:
        2×2 Jones矩阵
    """
    # 快轴沿x的矩阵
    M0 = np.array([[1, 0], [0, -1]], dtype=complex)

    # 旋转到指定角度
    theta = np.radians(fast_axis_deg)
    R = rotation_matrix(theta)
    R_inv = rotation_matrix(-theta)

    return R_inv @ M0 @ R


def jones_rotator(angle_deg):
    """
    光学旋转器的Jones矩阵

    J_rot(θ) = [[cosθ, -sinθ],
                [sinθ, cosθ]]

    旋转偏振方向，不改变偏振态类型

    参数:
        angle_deg: 旋转角度(度)

    返回:
        2×2 Jones矩阵
    """
    theta = np.radians(angle_deg)
    c = np.cos(theta)
    s = np.sin(theta)

    return np.array([
        [c, -s],
        [s, c]
    ], dtype=complex)


def jones_general_waveplate(retardance_deg, fast_axis_deg):
    """
    通用波片的Jones矩阵

    相位延迟为任意值

    快轴沿x时:
        J = [[e^(iΓ/2), 0],
             [0, e^(-iΓ/2)]]

    其中 Γ 是相位延迟

    参数:
        retardance_deg: 相位延迟(度)
        fast_axis_deg: 快轴角度(度)

    返回:
        2×2 Jones矩阵
    """
    gamma = np.radians(retardance_deg)

    # 快轴沿x的矩阵
    M0 = np.array([
        [np.exp(1j * gamma / 2), 0],
        [0, np.exp(-1j * gamma / 2)]
    ], dtype=complex)

    # 旋转到指定角度
    theta = np.radians(fast_axis_deg)
    R = rotation_matrix(theta)
    R_inv = rotation_matrix(-theta)

    return R_inv @ M0 @ R


def jones_faraday_rotator(angle_deg):
    """
    法拉第旋转器的Jones矩阵

    与普通旋转器相同，但基于磁光效应
    非互易性是其关键特性（用于光学隔离器）

    参数:
        angle_deg: 旋转角度(度)

    返回:
        2×2 Jones矩阵
    """
    return jones_rotator(angle_deg)


def jones_attenuator(transmission):
    """
    衰减器的Jones矩阵

    J = sqrt(T) · I

    其中 T 是透过率, I 是单位矩阵

    参数:
        transmission: 透过率 (0-1)

    返回:
        2×2 Jones矩阵
    """
    return np.sqrt(transmission) * np.eye(2, dtype=complex)


def rotation_matrix(theta_rad):
    """
    2×2旋转矩阵

    R(θ) = [[cosθ, sinθ],
            [-sinθ, cosθ]]

    参数:
        theta_rad: 旋转角度(弧度)

    返回:
        2×2 旋转矩阵
    """
    c = np.cos(theta_rad)
    s = np.sin(theta_rad)
    return np.array([[c, s], [-s, c]], dtype=complex)


def apply_jones_matrix(jones_matrix, jones_vector):
    """
    将Jones矩阵应用于Jones矢量

    E_out = J · E_in

    参数:
        jones_matrix: 2×2 Jones矩阵
        jones_vector: JonesVector对象或数组

    返回:
        JonesVector对象
    """
    if isinstance(jones_vector, JonesVector):
        E_in = jones_vector.to_array()
    else:
        E_in = np.array(jones_vector, dtype=complex)

    E_out = jones_matrix @ E_in
    return JonesVector(E_out[0], E_out[1])


# ============================================================================
# 可视化辅助函数
# ============================================================================

def draw_poincare_sphere(ax):
    """
    绘制Poincare球框架

    参数:
        ax: 3D axes对象
    """
    # 球面网格
    u = np.linspace(0, 2 * np.pi, 30)
    v = np.linspace(0, np.pi, 20)

    x = np.outer(np.cos(u), np.sin(v))
    y = np.outer(np.sin(u), np.sin(v))
    z = np.outer(np.ones(np.size(u)), np.cos(v))

    # 绘制半透明球面
    ax.plot_surface(x, y, z, alpha=0.1, color=COLORS['cyan'], linewidth=0)

    # 绘制经纬线
    # 赤道
    theta = np.linspace(0, 2*np.pi, 100)
    ax.plot(np.cos(theta), np.sin(theta), np.zeros_like(theta),
            color=COLORS['gray'], linewidth=1, linestyle=':')

    # 子午线
    for phi in [0, np.pi/4, np.pi/2, 3*np.pi/4]:
        ax.plot(np.cos(phi)*np.sin(theta), np.sin(phi)*np.sin(theta), np.cos(theta),
                color=COLORS['gray'], linewidth=0.5, linestyle=':')

    # 坐标轴
    ax.plot([-1.3, 1.3], [0, 0], [0, 0], color=COLORS['pink'], linewidth=1.5)
    ax.plot([0, 0], [-1.3, 1.3], [0, 0], color=COLORS['green'], linewidth=1.5)
    ax.plot([0, 0], [0, 0], [-1.3, 1.3], color=COLORS['cyan'], linewidth=1.5)

    # 轴标签
    ax.text(1.5, 0, 0, 'S₁ (H-V)', color=COLORS['pink'], fontsize=8)
    ax.text(0, 1.5, 0, 'S₂ (±45°)', color=COLORS['green'], fontsize=8)
    ax.text(0, 0, 1.5, 'S₃ (R-L)', color=COLORS['cyan'], fontsize=8)

    # 特殊点标记
    special_points = [
        (1, 0, 0, 'H'),    # 水平
        (-1, 0, 0, 'V'),   # 垂直
        (0, 1, 0, 'D'),    # +45°
        (0, -1, 0, 'A'),   # -45°
        (0, 0, 1, 'R'),    # 右圆
        (0, 0, -1, 'L'),   # 左圆
    ]

    for s1, s2, s3, label in special_points:
        ax.scatter([s1], [s2], [s3], color=COLORS['yellow'], s=30, marker='o')
        ax.text(s1*1.15, s2*1.15, s3*1.15, label, color=COLORS['yellow'],
                fontsize=9, ha='center', va='center')


def draw_jones_matrix_heatmap(ax, matrix, title='Jones Matrix'):
    """
    绘制Jones矩阵热图

    显示实部和虚部

    参数:
        ax: axes对象
        matrix: 2×2复数矩阵
        title: 标题
    """
    ax.clear()
    ax.set_facecolor(COLORS['panel'])

    # 计算实部和虚部
    real_part = np.real(matrix)
    imag_part = np.imag(matrix)

    # 创建2×4显示矩阵（实部和虚部并排）
    display = np.zeros((2, 4))
    display[:, :2] = real_part
    display[:, 2:] = imag_part

    # 颜色映射
    vmax = max(np.abs(display).max(), 1)
    im = ax.imshow(display, cmap='RdBu_r', vmin=-vmax, vmax=vmax,
                   aspect='auto', interpolation='nearest')

    # 添加数值标签
    for i in range(2):
        for j in range(2):
            # 实部
            val_r = real_part[i, j]
            color = 'white' if abs(val_r) > vmax * 0.5 else 'black'
            ax.text(j, i, f'{val_r:.2f}', ha='center', va='center',
                   color=color, fontsize=10, fontweight='bold')
            # 虚部
            val_i = imag_part[i, j]
            color = 'white' if abs(val_i) > vmax * 0.5 else 'black'
            suffix = 'i' if val_i != 0 else ''
            ax.text(j + 2, i, f'{val_i:.2f}{suffix}', ha='center', va='center',
                   color=color, fontsize=10, fontweight='bold')

    # 分隔线
    ax.axvline(x=1.5, color=COLORS['white'], linewidth=2)

    # 标签
    ax.set_xticks([0.5, 2.5])
    ax.set_xticklabels(['Real', 'Imag'], color=COLORS['white'])
    ax.set_yticks([0, 1])
    ax.set_yticklabels(['Ex→', 'Ey→'], color=COLORS['white'])
    ax.tick_params(colors=COLORS['white'], length=0)

    ax.set_title(title, color=COLORS['white'], fontsize=10, fontweight='bold')

    # 边框
    for spine in ax.spines.values():
        spine.set_color(COLORS['gray'])


def draw_polarization_ellipse(ax, jones_vector, color=COLORS['cyan']):
    """
    绘制偏振椭圆

    参数:
        ax: axes对象
        jones_vector: JonesVector对象
        color: 颜色
    """
    ax.clear()
    ax.set_facecolor(COLORS['panel'])
    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-1.5, 1.5)
    ax.set_aspect('equal')
    ax.axis('off')

    # 参考圆
    theta = np.linspace(0, 2*np.pi, 100)
    ax.plot(np.cos(theta), np.sin(theta), ':', color=COLORS['gray'],
            linewidth=0.5, alpha=0.5)

    # 坐标轴
    ax.axhline(0, color=COLORS['gray'], linewidth=0.5, linestyle=':')
    ax.axvline(0, color=COLORS['gray'], linewidth=0.5, linestyle=':')

    # 分类偏振态
    pol_type, params = jones_vector.normalize().classify()

    if pol_type == 'linear':
        # 线偏振 - 双向箭头
        angle_rad = np.radians(params['angle'])
        dx = np.cos(angle_rad)
        dy = np.sin(angle_rad)

        arrow = FancyArrowPatch((-dx, -dy), (dx, dy),
                               arrowstyle='<->', mutation_scale=20,
                               linewidth=3, color=color)
        ax.add_patch(arrow)

        ax.text(0, -1.3, f"Linear\n{params['angle']:.1f}°",
               ha='center', va='top', color=color, fontsize=9)

    elif pol_type in ['circular-r', 'circular-l']:
        # 圆偏振 - 圆圈 + 旋转方向
        circle = Circle((0, 0), 1, fill=False, edgecolor=color, linewidth=2.5)
        ax.add_patch(circle)

        # 旋转方向箭头
        if pol_type == 'circular-r':
            ax.annotate('', xy=(0.7, 0.7), xytext=(-0.7, 0.7),
                       arrowprops=dict(arrowstyle='->', color=color, lw=2,
                                     connectionstyle="arc3,rad=0.3"))
            label = "Right Circular\n(RCP)"
        else:
            ax.annotate('', xy=(-0.7, 0.7), xytext=(0.7, 0.7),
                       arrowprops=dict(arrowstyle='->', color=color, lw=2,
                                     connectionstyle="arc3,rad=-0.3"))
            label = "Left Circular\n(LCP)"

        ax.text(0, -1.3, label, ha='center', va='top', color=color, fontsize=9)

    else:
        # 椭圆偏振
        # 计算椭圆参数
        stokes = jones_vector.to_stokes()
        S0 = stokes[0]
        if S0 > 1e-10:
            chi = 0.5 * np.arcsin(stokes[3] / S0)  # 椭圆度角
            psi = 0.5 * np.arctan2(stokes[2], stokes[1])  # 方位角
        else:
            chi, psi = 0, 0

        # 半轴
        a = np.cos(abs(chi))
        b = np.sin(abs(chi))

        # 绘制椭圆
        t = np.linspace(0, 2*np.pi, 100)
        x = a * np.cos(t)
        y = b * np.sin(t)

        # 旋转
        cos_psi = np.cos(psi)
        sin_psi = np.sin(psi)
        xr = x * cos_psi - y * sin_psi
        yr = x * sin_psi + y * cos_psi

        ax.plot(xr, yr, color=color, linewidth=2.5)

        # 旋转方向指示
        handedness = params.get('handedness', 'right')
        hand_symbol = '↻' if handedness == 'right' else '↺'
        ax.text(0, 0, hand_symbol, ha='center', va='center',
               color=color, fontsize=20, alpha=0.7)

        ax.text(0, -1.3, f"Elliptical\nψ={np.degrees(psi):.1f}°, χ={np.degrees(chi):.1f}°",
               ha='center', va='top', color=color, fontsize=8)


# ============================================================================
# 主演示类 (Main Demo Class)
# ============================================================================

class JonesMatrixDemo:
    """
    Jones矩阵交互演示

    功能:
    - 选择输入偏振态
    - 选择光学元件（偏振片、波片、旋转器）
    - 实时计算输出偏振态
    - 显示Jones矩阵热图
    - Poincare球3D可视化
    """

    def __init__(self):
        """初始化演示"""
        # 初始参数
        self.input_type = 'linear'  # 输入偏振类型
        self.input_angle = 45  # 输入角度（度）
        self.element_type = 'polarizer'  # 光学元件类型
        self.element_angle = 0  # 元件角度（度）

        # 创建图形窗口
        self.fig = plt.figure(figsize=(16, 10))
        self.fig.suptitle('Jones矩阵演示 (Jones Matrix Demonstration)',
                         fontsize=16, fontweight='bold', color=COLORS['white'])
        self.fig.patch.set_facecolor(COLORS['background'])

        # 创建子图布局
        self.create_layout()

        # 创建控件
        self.create_controls()

        # 初始绘制
        self.update_plot()

        plt.tight_layout(rect=[0, 0.15, 1, 0.95])
        plt.show()

    def create_layout(self):
        """创建子图布局"""
        # 主光路图 (左上)
        self.ax_main = plt.subplot2grid((3, 4), (0, 0), colspan=2, rowspan=2)
        self.ax_main.set_facecolor(COLORS['panel'])

        # Jones矩阵热图 (右上)
        self.ax_matrix = plt.subplot2grid((3, 4), (0, 2), colspan=1)
        self.ax_matrix.set_facecolor(COLORS['panel'])

        # 输入偏振态 (右上角)
        self.ax_input = plt.subplot2grid((3, 4), (0, 3))
        self.ax_input.set_facecolor(COLORS['panel'])

        # 输出偏振态 (右中)
        self.ax_output = plt.subplot2grid((3, 4), (1, 2))
        self.ax_output.set_facecolor(COLORS['panel'])

        # Poincare球 (右中下)
        self.ax_poincare = plt.subplot2grid((3, 4), (1, 3), projection='3d')
        self.ax_poincare.set_facecolor(COLORS['panel'])

        # 信息面板 (底部)
        self.ax_info = plt.subplot2grid((3, 4), (2, 0), colspan=4)
        self.ax_info.set_facecolor(COLORS['panel'])
        self.ax_info.axis('off')

    def create_controls(self):
        """创建交互控件"""
        # 输入偏振类型（单选按钮）
        ax_input_type = plt.axes([0.02, 0.75, 0.10, 0.18])
        ax_input_type.set_facecolor(COLORS['panel'])
        self.radio_input = RadioButtons(
            ax_input_type,
            ('Linear', 'Circular-R', 'Circular-L', '45° Diag', 'H', 'V'),
            active=0
        )
        self.radio_input.on_clicked(self.on_input_type_changed)

        # 设置单选按钮样式
        for label in self.radio_input.labels:
            label.set_color(COLORS['white'])
            label.set_fontsize(8)

        # 输入角度滑块（仅对线偏振有效）
        ax_input_angle = plt.axes([0.25, 0.08, 0.20, 0.03])
        ax_input_angle.set_facecolor(COLORS['slate'])
        self.slider_input_angle = Slider(
            ax_input_angle, 'Input Angle (°)',
            0, 180, valinit=self.input_angle,
            valstep=5, color=COLORS['orange']
        )
        self.slider_input_angle.on_changed(self.on_input_angle_changed)
        self.slider_input_angle.label.set_color(COLORS['white'])
        self.slider_input_angle.valtext.set_color(COLORS['white'])

        # 光学元件类型（单选按钮）
        ax_element_type = plt.axes([0.02, 0.45, 0.10, 0.25])
        ax_element_type.set_facecolor(COLORS['panel'])
        self.radio_element = RadioButtons(
            ax_element_type,
            ('Polarizer', 'λ/4 Waveplate', 'λ/2 Waveplate', 'Rotator', 'Attenuator'),
            active=0
        )
        self.radio_element.on_clicked(self.on_element_type_changed)

        for label in self.radio_element.labels:
            label.set_color(COLORS['white'])
            label.set_fontsize(8)

        # 元件角度滑块
        ax_element_angle = plt.axes([0.50, 0.08, 0.20, 0.03])
        ax_element_angle.set_facecolor(COLORS['slate'])
        self.slider_element_angle = Slider(
            ax_element_angle, 'Element Angle (°)',
            0, 180, valinit=self.element_angle,
            valstep=5, color=COLORS['yellow']
        )
        self.slider_element_angle.on_changed(self.on_element_angle_changed)
        self.slider_element_angle.label.set_color(COLORS['white'])
        self.slider_element_angle.valtext.set_color(COLORS['white'])

        # 重置按钮
        ax_reset = plt.axes([0.85, 0.08, 0.08, 0.04])
        self.btn_reset = Button(ax_reset, 'Reset',
                               color=COLORS['slate'], hovercolor=COLORS['gray'])
        self.btn_reset.on_clicked(self.on_reset)
        self.btn_reset.label.set_color(COLORS['white'])

    def get_input_jones(self):
        """获取输入Jones矢量"""
        if self.input_type == 'linear':
            return JonesVector.linear(self.input_angle)
        elif self.input_type == 'circular-r':
            return JonesVector.right_circular()
        elif self.input_type == 'circular-l':
            return JonesVector.left_circular()
        elif self.input_type == 'diagonal':
            return JonesVector.diagonal()
        elif self.input_type == 'h':
            return JonesVector.horizontal()
        elif self.input_type == 'v':
            return JonesVector.vertical()
        else:
            return JonesVector.linear(self.input_angle)

    def get_jones_matrix(self):
        """获取选定的Jones矩阵"""
        if self.element_type == 'polarizer':
            return jones_polarizer(self.element_angle), 'Linear Polarizer'
        elif self.element_type == 'quarter':
            return jones_quarter_waveplate(self.element_angle), 'λ/4 Waveplate'
        elif self.element_type == 'half':
            return jones_half_waveplate(self.element_angle), 'λ/2 Waveplate'
        elif self.element_type == 'rotator':
            return jones_rotator(self.element_angle), 'Rotator'
        elif self.element_type == 'attenuator':
            return jones_attenuator(0.5), 'Attenuator (50%)'
        else:
            return np.eye(2, dtype=complex), 'Identity'

    def on_input_type_changed(self, label):
        """输入类型改变回调"""
        type_map = {
            'Linear': 'linear',
            'Circular-R': 'circular-r',
            'Circular-L': 'circular-l',
            '45° Diag': 'diagonal',
            'H': 'h',
            'V': 'v'
        }
        self.input_type = type_map.get(label, 'linear')
        self.update_plot()

    def on_input_angle_changed(self, val):
        """输入角度改变回调"""
        self.input_angle = val
        self.update_plot()

    def on_element_type_changed(self, label):
        """元件类型改变回调"""
        type_map = {
            'Polarizer': 'polarizer',
            'λ/4 Waveplate': 'quarter',
            'λ/2 Waveplate': 'half',
            'Rotator': 'rotator',
            'Attenuator': 'attenuator'
        }
        self.element_type = type_map.get(label, 'polarizer')
        self.update_plot()

    def on_element_angle_changed(self, val):
        """元件角度改变回调"""
        self.element_angle = val
        self.update_plot()

    def on_reset(self, event):
        """重置回调"""
        self.input_type = 'linear'
        self.input_angle = 45
        self.element_type = 'polarizer'
        self.element_angle = 0

        self.slider_input_angle.set_val(45)
        self.slider_element_angle.set_val(0)
        self.radio_input.set_active(0)
        self.radio_element.set_active(0)

        self.update_plot()

    def update_plot(self):
        """更新所有图形"""
        # 获取Jones矢量和矩阵
        input_jones = self.get_input_jones()
        jones_matrix, element_name = self.get_jones_matrix()
        output_jones = apply_jones_matrix(jones_matrix, input_jones)

        # 1. 绘制光路图
        self.draw_optical_path(input_jones, jones_matrix, output_jones, element_name)

        # 2. 绘制Jones矩阵热图
        draw_jones_matrix_heatmap(self.ax_matrix, jones_matrix, f'{element_name}\nJones Matrix')

        # 3. 绘制输入偏振态
        self.ax_input.set_title('Input', color=COLORS['white'], fontsize=10)
        draw_polarization_ellipse(self.ax_input, input_jones, COLORS['orange'])

        # 4. 绘制输出偏振态
        self.ax_output.set_title('Output', color=COLORS['white'], fontsize=10)
        output_color = COLORS['green'] if output_jones.intensity() > 0.01 else COLORS['gray']
        draw_polarization_ellipse(self.ax_output, output_jones, output_color)

        # 5. 更新Poincare球
        self.draw_poincare(input_jones, output_jones)

        # 6. 更新信息面板
        self.draw_info_panel(input_jones, jones_matrix, output_jones, element_name)

        # 刷新
        self.fig.canvas.draw_idle()

    def draw_optical_path(self, input_jones, jones_matrix, output_jones, element_name):
        """绘制光路示意图"""
        ax = self.ax_main
        ax.clear()
        ax.set_facecolor(COLORS['panel'])
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 5)
        ax.axis('off')

        # 光源
        source = Circle((1, 2.5), 0.4, color=COLORS['yellow'], alpha=0.8)
        ax.add_patch(source)
        ax.text(1, 1.7, 'Light Source', ha='center', va='top',
               color=COLORS['gray'], fontsize=9)

        # 输入光束
        input_intensity = input_jones.intensity()
        ax.arrow(1.5, 2.5, 1.8, 0, head_width=0.15, head_length=0.2,
                fc=COLORS['orange'], ec=COLORS['orange'],
                alpha=min(input_intensity, 1), linewidth=3)

        # 输入偏振方向指示
        input_type, input_params = input_jones.classify()
        if input_type == 'linear':
            angle_rad = np.radians(input_params['angle'])
            dx = 0.3 * np.cos(angle_rad)
            dy = 0.3 * np.sin(angle_rad)
            arrow = FancyArrowPatch((2.5 - dx, 2.5 - dy), (2.5 + dx, 2.5 + dy),
                                   arrowstyle='<->', mutation_scale=15,
                                   linewidth=2.5, color=COLORS['orange'])
            ax.add_patch(arrow)
        elif input_type in ['circular-r', 'circular-l']:
            circ = Circle((2.5, 2.5), 0.25, fill=False, edgecolor=COLORS['orange'],
                         linewidth=2)
            ax.add_patch(circ)

        # 光学元件
        element_x = 5

        # 根据元件类型选择颜色和形状
        if self.element_type == 'polarizer':
            element_color = COLORS['pink']
            rect = Rectangle((element_x - 0.3, 1.5), 0.6, 2,
                            facecolor=element_color, edgecolor=element_color,
                            alpha=0.4, linewidth=2)
            ax.add_patch(rect)

            # 透射轴指示
            angle_rad = np.radians(self.element_angle)
            dx = 0.7 * np.cos(angle_rad)
            dy = 0.7 * np.sin(angle_rad)
            arrow = FancyArrowPatch((element_x - dx, 2.5 - dy),
                                   (element_x + dx, 2.5 + dy),
                                   arrowstyle='->', mutation_scale=15,
                                   linewidth=2.5, color=element_color)
            ax.add_patch(arrow)

        elif self.element_type in ['quarter', 'half']:
            element_color = COLORS['purple']
            ellipse = Ellipse((element_x, 2.5), 0.8, 2,
                             facecolor=element_color, edgecolor=element_color,
                             alpha=0.3, linewidth=2)
            ax.add_patch(ellipse)

            # 快轴指示
            angle_rad = np.radians(self.element_angle)
            dx = 0.6 * np.cos(angle_rad)
            dy = 0.6 * np.sin(angle_rad)
            ax.plot([element_x - dx, element_x + dx],
                   [2.5 - dy, 2.5 + dy], color=COLORS['yellow'], linewidth=2.5)

            # 慢轴
            dx_s = 0.5 * np.cos(angle_rad + np.pi/2)
            dy_s = 0.5 * np.sin(angle_rad + np.pi/2)
            ax.plot([element_x - dx_s, element_x + dx_s],
                   [2.5 - dy_s, 2.5 + dy_s], '--', color=COLORS['cyan'], linewidth=2)

        elif self.element_type == 'rotator':
            element_color = COLORS['green']
            circle = Circle((element_x, 2.5), 0.5, facecolor=element_color,
                           edgecolor=element_color, alpha=0.4, linewidth=2)
            ax.add_patch(circle)
            ax.text(element_x, 2.5, '↻', ha='center', va='center',
                   color=element_color, fontsize=20)

        else:  # attenuator
            element_color = COLORS['gray']
            rect = Rectangle((element_x - 0.3, 1.8), 0.6, 1.4,
                            facecolor=element_color, edgecolor=element_color,
                            alpha=0.5, linewidth=2)
            ax.add_patch(rect)

        ax.text(element_x, 1.2, element_name, ha='center', va='top',
               color=element_color, fontsize=10, fontweight='bold')
        ax.text(element_x, 0.8, f'{self.element_angle}°', ha='center', va='top',
               color=element_color, fontsize=9)

        # 输出光束
        output_intensity = output_jones.intensity()
        if output_intensity > 0.01:
            output_color = COLORS['green']
            ax.arrow(5.5, 2.5, 2.0, 0, head_width=0.15, head_length=0.2,
                    fc=output_color, ec=output_color,
                    alpha=min(output_intensity, 1), linewidth=3)
        else:
            ax.plot([5.5, 7.5], [2.5, 2.5], ':', color=COLORS['gray'],
                   linewidth=2, alpha=0.5)
            ax.text(6.5, 3, 'Blocked', ha='center', color=COLORS['gray'],
                   fontsize=9, style='italic')

        # 探测器/屏幕
        screen = Rectangle((8.3, 1.7), 0.4, 1.6, facecolor=COLORS['slate'],
                          edgecolor=COLORS['gray'], linewidth=2)
        ax.add_patch(screen)

        # 屏幕上的光斑
        if output_intensity > 0.01:
            spot = Circle((8.5, 2.5), 0.25, color=output_color,
                         alpha=min(output_intensity, 1))
            ax.add_patch(spot)

        ax.text(8.5, 1.3, 'Screen', ha='center', va='top',
               color=COLORS['gray'], fontsize=9)

        # 强度标注
        ax.text(2.5, 3.5, f'I_in = {input_intensity:.2f}', ha='center',
               color=COLORS['orange'], fontsize=9)
        if output_intensity > 0.01:
            ax.text(7, 3.5, f'I_out = {output_intensity:.2f}', ha='center',
                   color=COLORS['green'], fontsize=9)

    def draw_poincare(self, input_jones, output_jones):
        """绘制Poincare球"""
        ax = self.ax_poincare
        ax.clear()
        ax.set_facecolor(COLORS['panel'])

        # 绘制球面框架
        draw_poincare_sphere(ax)

        # 输入点
        s1_in, s2_in, s3_in = input_jones.to_poincare()
        ax.scatter([s1_in], [s2_in], [s3_in], color=COLORS['orange'],
                  s=100, marker='o', label='Input', zorder=10)

        # 输出点
        if output_jones.intensity() > 0.01:
            s1_out, s2_out, s3_out = output_jones.normalize().to_poincare()
            ax.scatter([s1_out], [s2_out], [s3_out], color=COLORS['green'],
                      s=100, marker='s', label='Output', zorder=10)

            # 连接线
            ax.plot([s1_in, s1_out], [s2_in, s2_out], [s3_in, s3_out],
                   '--', color=COLORS['white'], linewidth=1, alpha=0.5)

        # 设置
        ax.set_xlim(-1.5, 1.5)
        ax.set_ylim(-1.5, 1.5)
        ax.set_zlim(-1.5, 1.5)
        ax.set_title('Poincaré Sphere', color=COLORS['white'], fontsize=10)
        ax.legend(loc='upper left', fontsize=7, facecolor=COLORS['panel'],
                 edgecolor=COLORS['gray'], labelcolor=COLORS['white'])

        # 隐藏刻度
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_zticks([])
        ax.xaxis.pane.fill = False
        ax.yaxis.pane.fill = False
        ax.zaxis.pane.fill = False

    def draw_info_panel(self, input_jones, jones_matrix, output_jones, element_name):
        """绘制信息面板"""
        ax = self.ax_info
        ax.clear()
        ax.set_facecolor(COLORS['panel'])
        ax.axis('off')
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 2)

        # 输入信息
        input_type, input_params = input_jones.classify()
        input_stokes = input_jones.to_stokes()

        ax.text(0.1, 1.8, '【Input Polarization】', fontsize=10, fontweight='bold',
               color=COLORS['orange'])

        input_text = f"Type: {input_type.capitalize()}"
        if input_type == 'linear':
            input_text += f" ({input_params['angle']:.1f}°)"
        ax.text(0.1, 1.4, input_text, fontsize=9, color=COLORS['white'])

        ax.text(0.1, 1.0, f"Jones: [{input_jones.Ex:.3f}, {input_jones.Ey:.3f}]ᵀ",
               fontsize=8, color=COLORS['gray'], family='monospace')
        ax.text(0.1, 0.6, f"Stokes: [S₀={input_stokes[0]:.2f}, S₁={input_stokes[1]:.2f}, "
               f"S₂={input_stokes[2]:.2f}, S₃={input_stokes[3]:.2f}]",
               fontsize=8, color=COLORS['gray'], family='monospace')

        # Jones矩阵信息
        ax.text(3.5, 1.8, '【Jones Matrix】', fontsize=10, fontweight='bold',
               color=COLORS['yellow'])

        ax.text(3.5, 1.4, f"Element: {element_name}", fontsize=9, color=COLORS['white'])
        ax.text(3.5, 1.0, f"Angle: {self.element_angle}°", fontsize=9, color=COLORS['white'])

        # 矩阵元素
        m_str = f"J = [[{jones_matrix[0,0]:.2f}, {jones_matrix[0,1]:.2f}], "
        m_str += f"[{jones_matrix[1,0]:.2f}, {jones_matrix[1,1]:.2f}]]"
        ax.text(3.5, 0.6, m_str, fontsize=7, color=COLORS['gray'], family='monospace')

        # 输出信息
        output_type, output_params = output_jones.classify()
        output_stokes = output_jones.to_stokes()
        output_intensity = output_jones.intensity()

        ax.text(7, 1.8, '【Output Polarization】', fontsize=10, fontweight='bold',
               color=COLORS['green'] if output_intensity > 0.01 else COLORS['gray'])

        if output_intensity > 0.01:
            output_text = f"Type: {output_type.capitalize()}"
            if output_type == 'linear':
                output_text += f" ({output_params['angle']:.1f}°)"
            elif output_type == 'elliptical':
                output_text += f" (ψ={output_params['psi']:.1f}°)"
            ax.text(7, 1.4, output_text, fontsize=9, color=COLORS['white'])

            ax.text(7, 1.0, f"Intensity: {output_intensity:.3f} ({output_intensity*100:.1f}%)",
                   fontsize=9, color=COLORS['white'])
        else:
            ax.text(7, 1.4, "Blocked (I ≈ 0)", fontsize=9, color=COLORS['gray'],
                   style='italic')

        # 公式提示
        formula = "E_out = J · E_in"
        ax.text(5, 0.1, formula, fontsize=11, color=COLORS['cyan'],
               ha='center', fontweight='bold', style='italic')


# ============================================================================
# 主程序入口
# ============================================================================

if __name__ == '__main__':
    print("=" * 70)
    print("Jones矩阵演示 (Jones Matrix Demonstration)")
    print("=" * 70)
    print()
    print("物理原理:")
    print("  Jones矢量 E = [Ex, Ey]^T 描述完全相干偏振光")
    print("  Jones矩阵 J (2×2复数矩阵) 描述光学元件变换")
    print("  偏振态变换: E_out = J · E_in")
    print()
    print("支持的光学元件:")
    print("  1. 线偏振片 (Linear Polarizer)")
    print("  2. λ/4波片 (Quarter Waveplate)")
    print("  3. λ/2波片 (Half Waveplate)")
    print("  4. 旋转器 (Rotator)")
    print("  5. 衰减器 (Attenuator)")
    print()
    print("交互说明:")
    print("  - 选择输入偏振类型")
    print("  - 调整输入角度滑块（仅对线偏振有效）")
    print("  - 选择光学元件类型")
    print("  - 调整元件角度")
    print("  - 观察Poincare球上偏振态的变化")
    print()
    print("应用场景:")
    print("  • 光纤通信中的偏振控制")
    print("  • 液晶显示器的偏振调制")
    print("  • 光学隔离器设计")
    print("  • 偏振测量仪器校准")
    print()
    print("-" * 70)
    print("正在启动交互演示...")
    print()

    # 启动演示
    demo = JonesMatrixDemo()
