% Jones矩阵演示 (Jones Matrix Demonstration)
% ============================================
%
% 完整的Jones矩阵偏振光学演示程序，包含Jones矢量、Jones矩阵计算、
% 偏振态变换可视化以及Poincare球3D显示。
%
% 物理原理 (Physical Principles):
% ------------------------------
% 1. Jones矢量 (Jones Vector):
%    E = [Ex; Ey] = [|Ex|*exp(i*phi_x); |Ey|*exp(i*phi_y)]
%
%    常见偏振态:
%    - 水平偏振 (H): |H> = [1; 0]
%    - 垂直偏振 (V): |V> = [0; 1]
%    - 45度偏振 (D): |D> = 1/sqrt(2) * [1; 1]
%    - 右圆偏振 (R): |R> = 1/sqrt(2) * [1; -i]
%    - 左圆偏振 (L): |L> = 1/sqrt(2) * [1; i]
%
% 2. Jones矩阵 (Jones Matrix):
%    2x2复数矩阵，描述光学元件对偏振态的变换
%    E_out = J * E_in
%
%    常见Jones矩阵:
%    - 线偏振片(theta): J_pol = [cos^2(theta), sin(theta)cos(theta);
%                                sin(theta)cos(theta), sin^2(theta)]
%    - lambda/4波片:    J_QWP = [1, 0; 0, -i]  (快轴沿x)
%    - lambda/2波片:    J_HWP = [1, 0; 0, -1]  (快轴沿x)
%    - 旋转器(theta):   J_rot = [cos(theta), -sin(theta);
%                               sin(theta), cos(theta)]
%
% 3. Stokes参数 (Stokes Parameters):
%    S0 = |Ex|^2 + |Ey|^2    (总强度)
%    S1 = |Ex|^2 - |Ey|^2    (水平-垂直)
%    S2 = 2*Re(Ex*conj(Ey))  (±45度)
%    S3 = 2*Im(Ex*conj(Ey))  (圆偏振)
%
% 应用场景:
% --------
% - 光纤通信中的偏振控制
% - 液晶显示器的偏振调制
% - 光学隔离器设计
% - 偏振测量仪器校准
%
% 兼容性:
% -------
% MATLAB R2016b+ 或 GNU Octave 4.0+
% 无需额外工具箱
%
% 使用方法:
% ---------
% 在MATLAB或Octave中运行: jones_matrix
%
% 作者: PolarCraft Team (Generated by Claude)
% 日期: 2026-01-14
% 许可: MIT License

function jones_matrix()
    % 主函数 - Jones矩阵演示

    fprintf('====================================================\n');
    fprintf('Jones矩阵演示 (Jones Matrix Demonstration)\n');
    fprintf('====================================================\n\n');
    fprintf('物理原理:\n');
    fprintf('  Jones矢量 E = [Ex; Ey] 描述完全相干偏振光\n');
    fprintf('  Jones矩阵 J (2x2复数矩阵) 描述光学元件变换\n');
    fprintf('  偏振态变换: E_out = J * E_in\n\n');
    fprintf('支持的光学元件:\n');
    fprintf('  1. 线偏振片 (Linear Polarizer)\n');
    fprintf('  2. λ/4波片 (Quarter Waveplate)\n');
    fprintf('  3. λ/2波片 (Half Waveplate)\n');
    fprintf('  4. 旋转器 (Rotator)\n\n');
    fprintf('交互说明:\n');
    fprintf('  - 使用按钮选择输入偏振类型和光学元件\n');
    fprintf('  - 拖动滑块调整角度参数\n');
    fprintf('  - 观察Poincare球上偏振态的变化\n\n');

    % 创建图形窗口
    fig = figure('Name', 'Jones Matrix Demo', ...
                 'NumberTitle', 'off', ...
                 'Position', [50, 50, 1400, 800], ...
                 'Color', [0.06, 0.09, 0.16], ...
                 'Resize', 'on');

    % 初始化参数结构体
    params = struct();
    params.input_type = 'linear';       % 输入偏振类型
    params.input_angle = 45;            % 输入角度(度)
    params.element_type = 'polarizer';  % 光学元件类型
    params.element_angle = 0;           % 元件角度(度)

    % 保存参数到figure
    setappdata(fig, 'params', params);

    % 创建UI控件
    create_ui_controls(fig);

    % 初始绘制
    update_all_plots(fig);
end

% ============================================================================
% UI控件创建
% ============================================================================

function create_ui_controls(fig)
    % 创建所有UI控件

    controls = struct();

    % --- 输入偏振类型按钮组 ---
    % 标题
    uicontrol('Parent', fig, ...
        'Style', 'text', ...
        'String', 'Input Polarization', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.90, 0.12, 0.03], ...
        'BackgroundColor', [0.06, 0.09, 0.16], ...
        'ForegroundColor', [1, 1, 1], ...
        'FontSize', 10, 'FontWeight', 'bold');

    % Linear按钮
    controls.btn_linear = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'Linear', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.85, 0.06, 0.04], ...
        'BackgroundColor', [1, 0.67, 0], ...
        'ForegroundColor', [1, 1, 1], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_input_type_changed(fig, 'linear'));

    % H (Horizontal)按钮
    controls.btn_h = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'H', ...
        'Units', 'normalized', ...
        'Position', [0.085, 0.85, 0.03, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_input_type_changed(fig, 'h'));

    % V (Vertical)按钮
    controls.btn_v = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'V', ...
        'Units', 'normalized', ...
        'Position', [0.118, 0.85, 0.03, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_input_type_changed(fig, 'v'));

    % D (Diagonal 45度)按钮
    controls.btn_d = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'D(45°)', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.80, 0.045, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_input_type_changed(fig, 'diagonal'));

    % R (Right Circular)按钮
    controls.btn_r = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'R', ...
        'Units', 'normalized', ...
        'Position', [0.07, 0.80, 0.035, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_input_type_changed(fig, 'circular-r'));

    % L (Left Circular)按钮
    controls.btn_l = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'L', ...
        'Units', 'normalized', ...
        'Position', [0.11, 0.80, 0.035, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_input_type_changed(fig, 'circular-l'));

    % --- 输入角度滑块 ---
    controls.label_input_angle = uicontrol('Parent', fig, ...
        'Style', 'text', ...
        'String', 'Input Angle: 45°', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.73, 0.12, 0.03], ...
        'BackgroundColor', [0.06, 0.09, 0.16], ...
        'ForegroundColor', [1, 0.67, 0], ...
        'FontSize', 9);

    controls.slider_input = uicontrol('Parent', fig, ...
        'Style', 'slider', ...
        'Min', 0, 'Max', 180, 'Value', 45, ...
        'SliderStep', [5/180, 15/180], ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.70, 0.12, 0.025], ...
        'Callback', @(src, evt) on_input_angle_changed(fig, src));

    % --- 光学元件类型按钮组 ---
    uicontrol('Parent', fig, ...
        'Style', 'text', ...
        'String', 'Optical Element', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.63, 0.12, 0.03], ...
        'BackgroundColor', [0.06, 0.09, 0.16], ...
        'ForegroundColor', [1, 1, 1], ...
        'FontSize', 10, 'FontWeight', 'bold');

    % Polarizer按钮
    controls.btn_pol = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'Polarizer', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.58, 0.06, 0.04], ...
        'BackgroundColor', [0.96, 0.45, 0.71], ...
        'ForegroundColor', [1, 1, 1], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_element_type_changed(fig, 'polarizer'));

    % QWP按钮
    controls.btn_qwp = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'λ/4', ...
        'Units', 'normalized', ...
        'Position', [0.085, 0.58, 0.03, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_element_type_changed(fig, 'quarter'));

    % HWP按钮
    controls.btn_hwp = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'λ/2', ...
        'Units', 'normalized', ...
        'Position', [0.118, 0.58, 0.03, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_element_type_changed(fig, 'half'));

    % Rotator按钮
    controls.btn_rot = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'Rotator', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.53, 0.06, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [0.7, 0.7, 0.7], ...
        'FontSize', 9, ...
        'Callback', @(src, evt) on_element_type_changed(fig, 'rotator'));

    % --- 元件角度滑块 ---
    controls.label_element_angle = uicontrol('Parent', fig, ...
        'Style', 'text', ...
        'String', 'Element Angle: 0°', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.46, 0.12, 0.03], ...
        'BackgroundColor', [0.06, 0.09, 0.16], ...
        'ForegroundColor', [0.98, 0.75, 0.21], ...
        'FontSize', 9);

    controls.slider_element = uicontrol('Parent', fig, ...
        'Style', 'slider', ...
        'Min', 0, 'Max', 180, 'Value', 0, ...
        'SliderStep', [5/180, 15/180], ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.43, 0.12, 0.025], ...
        'Callback', @(src, evt) on_element_angle_changed(fig, src));

    % --- 重置按钮 ---
    controls.btn_reset = uicontrol('Parent', fig, ...
        'Style', 'pushbutton', ...
        'String', 'Reset', ...
        'Units', 'normalized', ...
        'Position', [0.02, 0.35, 0.06, 0.04], ...
        'BackgroundColor', [0.2, 0.25, 0.33], ...
        'ForegroundColor', [1, 1, 1], ...
        'FontSize', 10, ...
        'Callback', @(src, evt) on_reset(fig));

    % 保存控件句柄
    setappdata(fig, 'controls', controls);
end

% ============================================================================
% 回调函数
% ============================================================================

function on_input_type_changed(fig, input_type)
    % 输入偏振类型改变回调

    params = getappdata(fig, 'params');
    params.input_type = input_type;
    setappdata(fig, 'params', params);

    % 更新按钮颜色
    update_input_buttons(fig, input_type);

    % 更新图形
    update_all_plots(fig);
end

function on_input_angle_changed(fig, src)
    % 输入角度改变回调

    params = getappdata(fig, 'params');
    params.input_angle = get(src, 'Value');
    setappdata(fig, 'params', params);

    % 更新标签
    controls = getappdata(fig, 'controls');
    set(controls.label_input_angle, 'String', ...
        sprintf('Input Angle: %.0f°', params.input_angle));

    % 更新图形
    update_all_plots(fig);
end

function on_element_type_changed(fig, element_type)
    % 光学元件类型改变回调

    params = getappdata(fig, 'params');
    params.element_type = element_type;
    setappdata(fig, 'params', params);

    % 更新按钮颜色
    update_element_buttons(fig, element_type);

    % 更新图形
    update_all_plots(fig);
end

function on_element_angle_changed(fig, src)
    % 元件角度改变回调

    params = getappdata(fig, 'params');
    params.element_angle = get(src, 'Value');
    setappdata(fig, 'params', params);

    % 更新标签
    controls = getappdata(fig, 'controls');
    set(controls.label_element_angle, 'String', ...
        sprintf('Element Angle: %.0f°', params.element_angle));

    % 更新图形
    update_all_plots(fig);
end

function on_reset(fig)
    % 重置回调

    params = struct();
    params.input_type = 'linear';
    params.input_angle = 45;
    params.element_type = 'polarizer';
    params.element_angle = 0;
    setappdata(fig, 'params', params);

    % 重置滑块
    controls = getappdata(fig, 'controls');
    set(controls.slider_input, 'Value', 45);
    set(controls.slider_element, 'Value', 0);
    set(controls.label_input_angle, 'String', 'Input Angle: 45°');
    set(controls.label_element_angle, 'String', 'Element Angle: 0°');

    % 重置按钮颜色
    update_input_buttons(fig, 'linear');
    update_element_buttons(fig, 'polarizer');

    % 更新图形
    update_all_plots(fig);
end

function update_input_buttons(fig, active_type)
    % 更新输入类型按钮颜色

    controls = getappdata(fig, 'controls');
    active_color = [1, 0.67, 0];
    inactive_bg = [0.2, 0.25, 0.33];
    inactive_fg = [0.7, 0.7, 0.7];

    % 重置所有按钮
    set(controls.btn_linear, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_h, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_v, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_d, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_r, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_l, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);

    % 高亮当前选中
    switch active_type
        case 'linear'
            set(controls.btn_linear, 'BackgroundColor', active_color, 'ForegroundColor', [1,1,1]);
        case 'h'
            set(controls.btn_h, 'BackgroundColor', active_color, 'ForegroundColor', [1,1,1]);
        case 'v'
            set(controls.btn_v, 'BackgroundColor', active_color, 'ForegroundColor', [1,1,1]);
        case 'diagonal'
            set(controls.btn_d, 'BackgroundColor', active_color, 'ForegroundColor', [1,1,1]);
        case 'circular-r'
            set(controls.btn_r, 'BackgroundColor', [0.13, 0.83, 0.93], 'ForegroundColor', [1,1,1]);
        case 'circular-l'
            set(controls.btn_l, 'BackgroundColor', [0.13, 0.83, 0.93], 'ForegroundColor', [1,1,1]);
    end
end

function update_element_buttons(fig, active_type)
    % 更新光学元件按钮颜色

    controls = getappdata(fig, 'controls');
    inactive_bg = [0.2, 0.25, 0.33];
    inactive_fg = [0.7, 0.7, 0.7];

    % 重置所有按钮
    set(controls.btn_pol, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_qwp, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_hwp, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);
    set(controls.btn_rot, 'BackgroundColor', inactive_bg, 'ForegroundColor', inactive_fg);

    % 高亮当前选中
    switch active_type
        case 'polarizer'
            set(controls.btn_pol, 'BackgroundColor', [0.96, 0.45, 0.71], 'ForegroundColor', [1,1,1]);
        case 'quarter'
            set(controls.btn_qwp, 'BackgroundColor', [0.65, 0.55, 0.98], 'ForegroundColor', [1,1,1]);
        case 'half'
            set(controls.btn_hwp, 'BackgroundColor', [0.65, 0.55, 0.98], 'ForegroundColor', [1,1,1]);
        case 'rotator'
            set(controls.btn_rot, 'BackgroundColor', [0.06, 0.72, 0.51], 'ForegroundColor', [1,1,1]);
    end
end

% ============================================================================
% 绘图更新
% ============================================================================

function update_all_plots(fig)
    % 更新所有图形

    params = getappdata(fig, 'params');

    % 获取输入Jones矢量
    input_jones = get_input_jones(params);

    % 获取Jones矩阵
    [jones_mat, element_name] = get_jones_matrix(params);

    % 计算输出Jones矢量
    output_jones = jones_mat * input_jones;

    % 清除现有axes
    delete(findobj(fig, 'Type', 'axes'));

    % 1. 光路图 (左上)
    ax_main = axes('Parent', fig, 'Position', [0.18, 0.50, 0.45, 0.45]);
    draw_optical_path(ax_main, params, input_jones, output_jones, element_name);

    % 2. Jones矩阵热图 (右上)
    ax_matrix = axes('Parent', fig, 'Position', [0.68, 0.70, 0.28, 0.25]);
    draw_jones_matrix(ax_matrix, jones_mat, element_name);

    % 3. 输入偏振态 (右中上)
    ax_input = axes('Parent', fig, 'Position', [0.68, 0.40, 0.12, 0.22]);
    draw_polarization_state(ax_input, input_jones, [1, 0.67, 0], 'Input');

    % 4. 输出偏振态 (右中下)
    ax_output = axes('Parent', fig, 'Position', [0.84, 0.40, 0.12, 0.22]);
    output_intensity = abs(output_jones(1))^2 + abs(output_jones(2))^2;
    if output_intensity > 0.01
        output_color = [0.27, 1, 0.27];
    else
        output_color = [0.58, 0.64, 0.69];
    end
    draw_polarization_state(ax_output, output_jones, output_color, 'Output');

    % 5. Poincare球 (左下)
    ax_poincare = axes('Parent', fig, 'Position', [0.18, 0.08, 0.35, 0.38]);
    draw_poincare_sphere(ax_poincare, input_jones, output_jones);

    % 6. 信息面板 (右下)
    ax_info = axes('Parent', fig, 'Position', [0.58, 0.08, 0.38, 0.28]);
    draw_info_panel(ax_info, input_jones, jones_mat, output_jones, element_name, params);
end

function jones = get_input_jones(params)
    % 获取输入Jones矢量

    switch params.input_type
        case 'linear'
            theta = deg2rad(params.input_angle);
            jones = [cos(theta); sin(theta)];
        case 'h'
            jones = [1; 0];
        case 'v'
            jones = [0; 1];
        case 'diagonal'
            jones = [1; 1] / sqrt(2);
        case 'circular-r'
            jones = [1; -1i] / sqrt(2);
        case 'circular-l'
            jones = [1; 1i] / sqrt(2);
        otherwise
            theta = deg2rad(params.input_angle);
            jones = [cos(theta); sin(theta)];
    end
end

function [M, name] = get_jones_matrix(params)
    % 获取Jones矩阵

    theta = deg2rad(params.element_angle);

    switch params.element_type
        case 'polarizer'
            % 线偏振片
            % J = [cos^2(theta), sin(theta)cos(theta);
            %      sin(theta)cos(theta), sin^2(theta)]
            c = cos(theta);
            s = sin(theta);
            M = [c^2, s*c; s*c, s^2];
            name = 'Linear Polarizer';

        case 'quarter'
            % λ/4波片
            % 快轴沿x: J = [1, 0; 0, -i]
            M0 = [1, 0; 0, -1i];
            % 旋转到theta角度
            R = rotation_matrix(theta);
            R_inv = rotation_matrix(-theta);
            M = R_inv * M0 * R;
            name = 'λ/4 Waveplate';

        case 'half'
            % λ/2波片
            % 快轴沿x: J = [1, 0; 0, -1]
            M0 = [1, 0; 0, -1];
            R = rotation_matrix(theta);
            R_inv = rotation_matrix(-theta);
            M = R_inv * M0 * R;
            name = 'λ/2 Waveplate';

        case 'rotator'
            % 旋转器
            % J = [cos(theta), -sin(theta); sin(theta), cos(theta)]
            M = rotation_matrix(theta);
            name = 'Rotator';

        otherwise
            M = eye(2);
            name = 'Identity';
    end
end

function R = rotation_matrix(theta)
    % 2x2旋转矩阵
    c = cos(theta);
    s = sin(theta);
    R = [c, s; -s, c];
end

% ============================================================================
% 绘图函数
% ============================================================================

function draw_optical_path(ax, params, input_jones, output_jones, element_name)
    % 绘制光路示意图

    hold(ax, 'on');
    axis(ax, [0, 10, 0, 5]);
    axis(ax, 'off');
    set(ax, 'Color', [0.12, 0.16, 0.23]);

    % 光源
    rectangle(ax, 'Position', [0.5, 2, 0.8, 1], 'Curvature', 1, ...
             'FaceColor', [0.98, 0.75, 0.21], 'EdgeColor', 'none');
    text(ax, 0.9, 1.5, 'Source', 'Color', [0.58, 0.64, 0.69], ...
        'HorizontalAlignment', 'center', 'FontSize', 8);

    % 输入光束
    plot(ax, [1.5, 3.5], [2.5, 2.5], '-', 'Color', [1, 0.67, 0], 'LineWidth', 3);

    % 输入偏振指示
    [pol_type, pol_angle] = classify_polarization(input_jones);
    if strcmp(pol_type, 'linear')
        draw_arrow(ax, 2.5, 2.5, deg2rad(pol_angle), 0.4, [1, 0.67, 0]);
    else
        rectangle(ax, 'Position', [2.2, 2.2, 0.6, 0.6], 'Curvature', 1, ...
                 'FaceColor', 'none', 'EdgeColor', [1, 0.67, 0], 'LineWidth', 2);
    end

    % 光学元件
    element_x = 5;
    switch params.element_type
        case 'polarizer'
            element_color = [0.96, 0.45, 0.71];
            rectangle(ax, 'Position', [element_x-0.3, 1.5, 0.6, 2], ...
                     'FaceColor', [element_color, 0.4], ...
                     'EdgeColor', element_color, 'LineWidth', 2);
            % 透射轴
            theta = deg2rad(params.element_angle);
            draw_arrow(ax, element_x, 2.5, theta, 0.7, element_color);

        case {'quarter', 'half'}
            element_color = [0.65, 0.55, 0.98];
            rectangle(ax, 'Position', [element_x-0.4, 1.5, 0.8, 2], 'Curvature', 0.5, ...
                     'FaceColor', [element_color, 0.3], ...
                     'EdgeColor', element_color, 'LineWidth', 2);
            % 快轴和慢轴
            theta = deg2rad(params.element_angle);
            dx = 0.6 * cos(theta);
            dy = 0.6 * sin(theta);
            plot(ax, [element_x-dx, element_x+dx], [2.5-dy, 2.5+dy], '-', ...
                'Color', [0.98, 0.75, 0.21], 'LineWidth', 2.5);
            dx_s = 0.5 * cos(theta + pi/2);
            dy_s = 0.5 * sin(theta + pi/2);
            plot(ax, [element_x-dx_s, element_x+dx_s], [2.5-dy_s, 2.5+dy_s], '--', ...
                'Color', [0.13, 0.83, 0.93], 'LineWidth', 2);

        case 'rotator'
            element_color = [0.06, 0.72, 0.51];
            rectangle(ax, 'Position', [element_x-0.4, 2.1, 0.8, 0.8], 'Curvature', 1, ...
                     'FaceColor', [element_color, 0.4], ...
                     'EdgeColor', element_color, 'LineWidth', 2);
            text(ax, element_x, 2.5, char(8635), 'FontSize', 20, ...
                'HorizontalAlignment', 'center', 'Color', element_color);
    end

    text(ax, element_x, 1.0, element_name, 'Color', element_color, ...
        'HorizontalAlignment', 'center', 'FontSize', 9, 'FontWeight', 'bold');
    text(ax, element_x, 0.6, sprintf('%.0f°', params.element_angle), ...
        'Color', element_color, 'HorizontalAlignment', 'center', 'FontSize', 8);

    % 输出光束
    output_intensity = abs(output_jones(1))^2 + abs(output_jones(2))^2;
    if output_intensity > 0.01
        output_color = [0.27, 1, 0.27];
        plot(ax, [5.5, 8], [2.5, 2.5], '-', 'Color', output_color, ...
            'LineWidth', 3 * sqrt(output_intensity));
    else
        plot(ax, [5.5, 8], [2.5, 2.5], ':', 'Color', [0.58, 0.64, 0.69], ...
            'LineWidth', 2);
        text(ax, 6.8, 3.2, 'Blocked', 'Color', [0.58, 0.64, 0.69], ...
            'FontSize', 9, 'FontAngle', 'italic', 'HorizontalAlignment', 'center');
    end

    % 探测器
    rectangle(ax, 'Position', [8.3, 1.8, 0.4, 1.4], ...
             'FaceColor', [0.2, 0.25, 0.33], ...
             'EdgeColor', [0.58, 0.64, 0.69], 'LineWidth', 2);
    if output_intensity > 0.01
        rectangle(ax, 'Position', [8.2, 2.2, 0.6, 0.6], 'Curvature', 1, ...
                 'FaceColor', output_color, 'EdgeColor', 'none');
    end
    text(ax, 8.5, 1.4, 'Screen', 'Color', [0.58, 0.64, 0.69], ...
        'HorizontalAlignment', 'center', 'FontSize', 8);

    % 强度标注
    input_intensity = abs(input_jones(1))^2 + abs(input_jones(2))^2;
    text(ax, 2.5, 3.5, sprintf('I_{in} = %.2f', input_intensity), ...
        'Color', [1, 0.67, 0], 'FontSize', 9, 'HorizontalAlignment', 'center');
    if output_intensity > 0.01
        text(ax, 7, 3.5, sprintf('I_{out} = %.2f', output_intensity), ...
            'Color', output_color, 'FontSize', 9, 'HorizontalAlignment', 'center');
    end
end

function draw_arrow(ax, x, y, angle_rad, length, color)
    % 绘制双向箭头
    dx = length * cos(angle_rad);
    dy = length * sin(angle_rad);

    plot(ax, [x-dx, x+dx], [y-dy, y+dy], '-', 'Color', color, 'LineWidth', 2.5);

    % 箭头头部
    arrow_len = 0.12;
    arrow_angle = pi/6;
    ax1 = angle_rad + pi - arrow_angle;
    ax2 = angle_rad + pi + arrow_angle;
    plot(ax, [x+dx, x+dx+arrow_len*cos(ax1)], [y+dy, y+dy+arrow_len*sin(ax1)], ...
        '-', 'Color', color, 'LineWidth', 2);
    plot(ax, [x+dx, x+dx+arrow_len*cos(ax2)], [y+dy, y+dy+arrow_len*sin(ax2)], ...
        '-', 'Color', color, 'LineWidth', 2);
end

function draw_jones_matrix(ax, jones_mat, element_name)
    % 绘制Jones矩阵热图

    hold(ax, 'on');
    set(ax, 'Color', [0.12, 0.16, 0.23]);

    % 实部和虚部
    real_part = real(jones_mat);
    imag_part = imag(jones_mat);

    % 创建显示矩阵
    display_mat = [real_part, imag_part];

    % 绘制热图
    imagesc(ax, display_mat);
    colormap(ax, redblue_colormap());
    vmax = max(abs(display_mat(:)));
    if vmax > 0
        caxis(ax, [-vmax, vmax]);
    else
        caxis(ax, [-1, 1]);
    end

    % 添加数值标签
    for i = 1:2
        for j = 1:2
            % 实部
            val_r = real_part(i, j);
            if abs(val_r) > vmax * 0.5
                txt_color = [1, 1, 1];
            else
                txt_color = [0, 0, 0];
            end
            text(ax, j, i, sprintf('%.2f', val_r), 'HorizontalAlignment', 'center', ...
                'Color', txt_color, 'FontSize', 10, 'FontWeight', 'bold');

            % 虚部
            val_i = imag_part(i, j);
            if abs(val_i) > vmax * 0.5
                txt_color = [1, 1, 1];
            else
                txt_color = [0, 0, 0];
            end
            if abs(val_i) > 1e-10
                text(ax, j+2, i, sprintf('%.2fi', val_i), 'HorizontalAlignment', 'center', ...
                    'Color', txt_color, 'FontSize', 10, 'FontWeight', 'bold');
            else
                text(ax, j+2, i, '0', 'HorizontalAlignment', 'center', ...
                    'Color', txt_color, 'FontSize', 10, 'FontWeight', 'bold');
            end
        end
    end

    % 分隔线
    plot(ax, [2.5, 2.5], [0.5, 2.5], '-', 'Color', [1, 1, 1], 'LineWidth', 2);

    % 标签
    set(ax, 'XTick', [1.5, 3.5], 'XTickLabel', {'Real', 'Imag'});
    set(ax, 'YTick', [1, 2], 'YTickLabel', {'Ex->', 'Ey->'});
    set(ax, 'TickDir', 'out');
    set(ax, 'XColor', [1, 1, 1], 'YColor', [1, 1, 1]);

    title(ax, [element_name, ' Jones Matrix'], 'Color', [1, 1, 1], ...
        'FontSize', 10, 'FontWeight', 'bold');

    axis(ax, [0.5, 4.5, 0.5, 2.5]);
end

function cmap = redblue_colormap()
    % 红蓝色图
    n = 64;
    r1 = linspace(0, 1, n/2);
    g1 = linspace(0, 1, n/2);
    b1 = ones(1, n/2);

    r2 = ones(1, n/2);
    g2 = linspace(1, 0, n/2);
    b2 = linspace(1, 0, n/2);

    cmap = [r1', g1', b1'; r2', g2', b2'];
end

function draw_polarization_state(ax, jones, color, title_str)
    % 绘制偏振态

    hold(ax, 'on');
    axis(ax, [-1.5, 1.5, -1.5, 1.5]);
    axis(ax, 'equal', 'off');
    set(ax, 'Color', [0.12, 0.16, 0.23]);

    % 参考圆
    theta = linspace(0, 2*pi, 100);
    plot(ax, cos(theta), sin(theta), ':', 'Color', [0.58, 0.64, 0.69], ...
        'LineWidth', 0.5);

    % 分类偏振态
    [pol_type, pol_angle] = classify_polarization(jones);

    if strcmp(pol_type, 'linear')
        % 线偏振
        angle_rad = deg2rad(pol_angle);
        dx = cos(angle_rad);
        dy = sin(angle_rad);
        plot(ax, [-dx, dx], [-dy, dy], '-', 'Color', color, 'LineWidth', 3);

        % 箭头
        arrow_len = 0.15;
        arrow_angle = pi/6;
        ax1 = angle_rad + pi - arrow_angle;
        ax2 = angle_rad + pi + arrow_angle;
        plot(ax, [dx, dx+arrow_len*cos(ax1)], [dy, dy+arrow_len*sin(ax1)], ...
            '-', 'Color', color, 'LineWidth', 2);
        plot(ax, [dx, dx+arrow_len*cos(ax2)], [dy, dy+arrow_len*sin(ax2)], ...
            '-', 'Color', color, 'LineWidth', 2);

        text(ax, 0, -1.35, sprintf('Linear\n%.0f°', pol_angle), ...
            'HorizontalAlignment', 'center', 'Color', color, 'FontSize', 8);

    elseif strcmp(pol_type, 'circular-r') || strcmp(pol_type, 'circular-l')
        % 圆偏振
        plot(ax, cos(theta), sin(theta), '-', 'Color', color, 'LineWidth', 2.5);

        if strcmp(pol_type, 'circular-r')
            text(ax, 0, 0, char(8635), 'FontSize', 30, 'HorizontalAlignment', 'center', ...
                'Color', color);
            label_str = sprintf('Right\nCircular');
        else
            text(ax, 0, 0, char(8634), 'FontSize', 30, 'HorizontalAlignment', 'center', ...
                'Color', color);
            label_str = sprintf('Left\nCircular');
        end
        text(ax, 0, -1.35, label_str, 'HorizontalAlignment', 'center', ...
            'Color', color, 'FontSize', 8);

    else
        % 椭圆偏振
        stokes = jones_to_stokes(jones);
        S0 = stokes(1);
        if S0 > 1e-10
            chi = 0.5 * asin(stokes(4) / S0);
            psi = 0.5 * atan2(stokes(3), stokes(2));
        else
            chi = 0;
            psi = 0;
        end

        a = cos(abs(chi));
        b = sin(abs(chi));

        t = linspace(0, 2*pi, 100);
        xe = a * cos(t);
        ye = b * sin(t);

        c = cos(psi);
        s = sin(psi);
        xr = xe * c - ye * s;
        yr = xe * s + ye * c;

        plot(ax, xr, yr, '-', 'Color', color, 'LineWidth', 2.5);

        text(ax, 0, -1.35, sprintf('Elliptical\nψ=%.0f°', rad2deg(psi)), ...
            'HorizontalAlignment', 'center', 'Color', color, 'FontSize', 8);
    end

    title(ax, title_str, 'Color', [1, 1, 1], 'FontSize', 10);
end

function draw_poincare_sphere(ax, input_jones, output_jones)
    % 绘制Poincare球

    hold(ax, 'on');
    set(ax, 'Color', [0.12, 0.16, 0.23]);

    % 球面网格
    [X, Y, Z] = sphere(30);
    surf(ax, X, Y, Z, 'FaceColor', [0.13, 0.83, 0.93], 'FaceAlpha', 0.1, ...
        'EdgeColor', 'none');

    % 经纬线
    theta = linspace(0, 2*pi, 100);

    % 赤道
    plot3(ax, cos(theta), sin(theta), zeros(size(theta)), ':', ...
        'Color', [0.58, 0.64, 0.69], 'LineWidth', 1);

    % 子午线
    for phi = [0, pi/4, pi/2, 3*pi/4]
        plot3(ax, cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta), ...
            ':', 'Color', [0.58, 0.64, 0.69], 'LineWidth', 0.5);
    end

    % 坐标轴
    plot3(ax, [-1.3, 1.3], [0, 0], [0, 0], '-', 'Color', [0.96, 0.45, 0.71], 'LineWidth', 1.5);
    plot3(ax, [0, 0], [-1.3, 1.3], [0, 0], '-', 'Color', [0.06, 0.72, 0.51], 'LineWidth', 1.5);
    plot3(ax, [0, 0], [0, 0], [-1.3, 1.3], '-', 'Color', [0.13, 0.83, 0.93], 'LineWidth', 1.5);

    % 轴标签
    text(ax, 1.5, 0, 0, 'S_1', 'Color', [0.96, 0.45, 0.71], 'FontSize', 9);
    text(ax, 0, 1.5, 0, 'S_2', 'Color', [0.06, 0.72, 0.51], 'FontSize', 9);
    text(ax, 0, 0, 1.5, 'S_3', 'Color', [0.13, 0.83, 0.93], 'FontSize', 9);

    % 特殊点
    special_pts = [1, 0, 0, 'H'; -1, 0, 0, 'V'; 0, 1, 0, 'D'; ...
                   0, -1, 0, 'A'; 0, 0, 1, 'R'; 0, 0, -1, 'L'];
    for i = 1:6
        s1 = str2double(special_pts{i,1});
        s2 = str2double(special_pts{i,2});
        s3 = str2double(special_pts{i,3});
        scatter3(ax, s1, s2, s3, 30, [0.98, 0.75, 0.21], 'filled');
        text(ax, s1*1.15, s2*1.15, s3*1.15, special_pts{i,4}, ...
            'Color', [0.98, 0.75, 0.21], 'FontSize', 8, 'HorizontalAlignment', 'center');
    end

    % 输入点
    stokes_in = jones_to_stokes(input_jones);
    S0_in = stokes_in(1);
    if S0_in > 1e-10
        s1_in = stokes_in(2) / S0_in;
        s2_in = stokes_in(3) / S0_in;
        s3_in = stokes_in(4) / S0_in;
        scatter3(ax, s1_in, s2_in, s3_in, 100, [1, 0.67, 0], 'filled', 'o');
    end

    % 输出点
    output_intensity = abs(output_jones(1))^2 + abs(output_jones(2))^2;
    if output_intensity > 0.01
        output_norm = output_jones / sqrt(output_intensity);
        stokes_out = jones_to_stokes(output_norm);
        S0_out = stokes_out(1);
        if S0_out > 1e-10
            s1_out = stokes_out(2) / S0_out;
            s2_out = stokes_out(3) / S0_out;
            s3_out = stokes_out(4) / S0_out;
            scatter3(ax, s1_out, s2_out, s3_out, 100, [0.27, 1, 0.27], 'filled', 's');

            % 连接线
            plot3(ax, [s1_in, s1_out], [s2_in, s2_out], [s3_in, s3_out], '--', ...
                'Color', [1, 1, 1], 'LineWidth', 1);
        end
    end

    % 设置视角
    view(ax, 135, 25);
    axis(ax, [-1.5, 1.5, -1.5, 1.5, -1.5, 1.5]);
    axis(ax, 'equal');
    set(ax, 'XTick', [], 'YTick', [], 'ZTick', []);
    set(ax, 'XColor', 'none', 'YColor', 'none', 'ZColor', 'none');

    title(ax, 'Poincaré Sphere', 'Color', [1, 1, 1], 'FontSize', 10);

    % 图例
    legend_txt = {'Input (O)', 'Output (□)'};
    text(ax, -1.3, -1.3, 1.3, legend_txt{1}, 'Color', [1, 0.67, 0], 'FontSize', 8);
    if output_intensity > 0.01
        text(ax, -1.3, -1.3, 1.0, legend_txt{2}, 'Color', [0.27, 1, 0.27], 'FontSize', 8);
    end
end

function draw_info_panel(ax, input_jones, jones_mat, output_jones, element_name, params)
    % 绘制信息面板

    hold(ax, 'on');
    set(ax, 'Color', [0.12, 0.16, 0.23]);
    axis(ax, [0, 10, 0, 3]);
    axis(ax, 'off');

    % 输入信息
    [pol_type, pol_angle] = classify_polarization(input_jones);
    stokes_in = jones_to_stokes(input_jones);

    text(ax, 0.1, 2.7, '【Input Polarization】', 'FontSize', 10, 'FontWeight', 'bold', ...
        'Color', [1, 0.67, 0]);

    if strcmp(pol_type, 'linear')
        input_text = sprintf('Type: Linear (%.0f°)', pol_angle);
    elseif strcmp(pol_type, 'circular-r')
        input_text = 'Type: Right Circular';
    elseif strcmp(pol_type, 'circular-l')
        input_text = 'Type: Left Circular';
    else
        input_text = 'Type: Elliptical';
    end
    text(ax, 0.1, 2.2, input_text, 'FontSize', 9, 'Color', [1, 1, 1]);

    jones_str = sprintf('Jones: [%.3f%+.3fi; %.3f%+.3fi]', ...
        real(input_jones(1)), imag(input_jones(1)), ...
        real(input_jones(2)), imag(input_jones(2)));
    text(ax, 0.1, 1.7, jones_str, 'FontSize', 8, 'Color', [0.58, 0.64, 0.69], ...
        'FontName', 'FixedWidth');

    stokes_str = sprintf('Stokes: [%.2f, %.2f, %.2f, %.2f]', ...
        stokes_in(1), stokes_in(2), stokes_in(3), stokes_in(4));
    text(ax, 0.1, 1.2, stokes_str, 'FontSize', 8, 'Color', [0.58, 0.64, 0.69], ...
        'FontName', 'FixedWidth');

    % Jones矩阵信息
    text(ax, 3.5, 2.7, '【Jones Matrix】', 'FontSize', 10, 'FontWeight', 'bold', ...
        'Color', [0.98, 0.75, 0.21]);
    text(ax, 3.5, 2.2, ['Element: ', element_name], 'FontSize', 9, 'Color', [1, 1, 1]);
    text(ax, 3.5, 1.7, sprintf('Angle: %.0f°', params.element_angle), ...
        'FontSize', 9, 'Color', [1, 1, 1]);

    mat_str = sprintf('J = [[%.2f%+.2fi, %.2f%+.2fi]; [%.2f%+.2fi, %.2f%+.2fi]]', ...
        real(jones_mat(1,1)), imag(jones_mat(1,1)), ...
        real(jones_mat(1,2)), imag(jones_mat(1,2)), ...
        real(jones_mat(2,1)), imag(jones_mat(2,1)), ...
        real(jones_mat(2,2)), imag(jones_mat(2,2)));
    text(ax, 3.5, 1.2, mat_str, 'FontSize', 7, 'Color', [0.58, 0.64, 0.69], ...
        'FontName', 'FixedWidth');

    % 输出信息
    output_intensity = abs(output_jones(1))^2 + abs(output_jones(2))^2;

    if output_intensity > 0.01
        output_color = [0.27, 1, 0.27];
    else
        output_color = [0.58, 0.64, 0.69];
    end

    text(ax, 7, 2.7, '【Output Polarization】', 'FontSize', 10, 'FontWeight', 'bold', ...
        'Color', output_color);

    if output_intensity > 0.01
        [out_type, out_angle] = classify_polarization(output_jones);
        if strcmp(out_type, 'linear')
            output_text = sprintf('Type: Linear (%.0f°)', out_angle);
        elseif strcmp(out_type, 'circular-r')
            output_text = 'Type: Right Circular';
        elseif strcmp(out_type, 'circular-l')
            output_text = 'Type: Left Circular';
        else
            output_text = 'Type: Elliptical';
        end
        text(ax, 7, 2.2, output_text, 'FontSize', 9, 'Color', [1, 1, 1]);
        text(ax, 7, 1.7, sprintf('Intensity: %.3f (%.1f%%)', ...
            output_intensity, output_intensity * 100), ...
            'FontSize', 9, 'Color', [1, 1, 1]);
    else
        text(ax, 7, 2.2, 'Blocked (I ≈ 0)', 'FontSize', 9, ...
            'Color', [0.58, 0.64, 0.69], 'FontAngle', 'italic');
    end

    % 公式
    text(ax, 5, 0.3, 'E_{out} = J \cdot E_{in}', 'FontSize', 12, ...
        'Color', [0.13, 0.83, 0.93], 'HorizontalAlignment', 'center', ...
        'FontWeight', 'bold', 'FontAngle', 'italic');
end

% ============================================================================
% 辅助函数
% ============================================================================

function [pol_type, pol_angle] = classify_polarization(jones)
    % 分类偏振态

    Ex = jones(1);
    Ey = jones(2);

    norm_val = sqrt(abs(Ex)^2 + abs(Ey)^2);
    if norm_val < 1e-10
        pol_type = 'linear';
        pol_angle = 0;
        return;
    end

    Ex_n = Ex / norm_val;
    Ey_n = Ey / norm_val;

    phase_diff = angle(Ey_n) - angle(Ex_n);
    phase_diff = mod(phase_diff + pi, 2*pi) - pi;

    amp_ratio = abs(Ey_n) / (abs(Ex_n) + 1e-10);

    tolerance = 0.05;

    % 线偏振
    if abs(phase_diff) < tolerance || abs(abs(phase_diff) - pi) < tolerance
        angle_rad = atan2(real(Ey_n), real(Ex_n));
        pol_angle = mod(rad2deg(angle_rad), 180);
        pol_type = 'linear';
        return;
    end

    % 圆偏振
    if abs(amp_ratio - 1) < tolerance
        if abs(abs(phase_diff) - pi/2) < tolerance
            if phase_diff < 0
                pol_type = 'circular-r';
            else
                pol_type = 'circular-l';
            end
            pol_angle = 0;
            return;
        end
    end

    % 椭圆偏振
    pol_type = 'elliptical';
    stokes = jones_to_stokes(jones);
    S0 = stokes(1);
    if S0 > 1e-10
        psi = 0.5 * atan2(stokes(3), stokes(2));
        pol_angle = rad2deg(psi);
    else
        pol_angle = 0;
    end
end

function stokes = jones_to_stokes(jones)
    % Jones矢量转Stokes参数

    Ex = jones(1);
    Ey = jones(2);

    S0 = abs(Ex)^2 + abs(Ey)^2;
    S1 = abs(Ex)^2 - abs(Ey)^2;
    S2 = 2 * real(Ex * conj(Ey));
    S3 = 2 * imag(Ex * conj(Ey));

    stokes = [S0; S1; S2; S3];
end
